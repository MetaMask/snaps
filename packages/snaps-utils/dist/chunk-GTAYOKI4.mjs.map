{"version":3,"sources":["../src/structs.ts"],"sourcesContent":["import { union } from '@metamask/snaps-sdk';\nimport type { NonEmptyArray } from '@metamask/utils';\nimport { assert, isObject } from '@metamask/utils';\nimport { bold, green, red } from 'chalk';\nimport type { Failure } from 'superstruct';\nimport {\n  is,\n  validate,\n  type as superstructType,\n  Struct,\n  StructError,\n  create,\n} from 'superstruct';\nimport type { AnyStruct } from 'superstruct/dist/utils';\n\nimport { indent } from './strings';\n\n/**\n * Infer a struct type, only if it matches the specified type. This is useful\n * for defining types and structs that are related to each other in separate\n * files.\n *\n * @example\n * ```typescript\n * // In file A\n * export type GetFileArgs = {\n *   path: string;\n *   encoding?: EnumToUnion<AuxiliaryFileEncoding>;\n * };\n *\n * // In file B\n * export const GetFileArgsStruct = object(...);\n *\n * // If the type and struct are in the same file, this will return the type.\n * // Otherwise, it will return `never`.\n * export type GetFileArgs =\n *   InferMatching<typeof GetFileArgsStruct, GetFileArgs>;\n * ```\n */\nexport type InferMatching<\n  StructType extends Struct<any, any>,\n  Type,\n> = StructType['TYPE'] extends Type ? Type : never;\n\n/**\n * Colorize a value with a color function. This is useful for colorizing values\n * in error messages. If colorization is disabled, the original value is\n * returned.\n *\n * @param value - The value to colorize.\n * @param colorFunction - The color function to use.\n * @param enabled - Whether to colorize the value.\n * @returns The colorized value, or the original value if colorization is\n * disabled.\n */\nfunction color(\n  value: string,\n  colorFunction: (value: string) => string,\n  enabled: boolean,\n) {\n  if (enabled) {\n    return colorFunction(value);\n  }\n\n  return value;\n}\n\n/**\n * Define a struct, and also define the name of the struct as the given name.\n *\n * This is useful for improving the error messages returned by `superstruct`.\n *\n * @param name - The name of the struct.\n * @param struct - The struct.\n * @returns The struct.\n */\nexport function named<Type, Schema>(\n  name: string,\n  struct: Struct<Type, Schema>,\n) {\n  return new Struct({\n    ...struct,\n    type: name,\n  });\n}\n\nexport class SnapsStructError<Type, Schema> extends StructError {\n  constructor(\n    struct: Struct<Type, Schema>,\n    prefix: string,\n    suffix: string,\n    failure: StructError,\n    failures: () => Generator<Failure>,\n    colorize = true,\n  ) {\n    super(failure, failures);\n\n    this.name = 'SnapsStructError';\n    this.message = `${prefix}.\\n\\n${getStructErrorMessage(\n      struct,\n      [...failures()],\n      colorize,\n    )}${suffix ? `\\n\\n${suffix}` : ''}`;\n  }\n}\n\ntype GetErrorOptions<Type, Schema> = {\n  struct: Struct<Type, Schema>;\n  prefix: string;\n  suffix?: string;\n  error: StructError;\n  colorize?: boolean;\n};\n\n/**\n * Converts an array to a generator function that yields the items in the\n * array.\n *\n * @param array - The array.\n * @returns A generator function.\n * @yields The items in the array.\n */\nexport function* arrayToGenerator<Type>(\n  array: Type[],\n): Generator<Type, void, undefined> {\n  for (const item of array) {\n    yield item;\n  }\n}\n\n/**\n * Returns a `SnapsStructError` with the given prefix and suffix.\n *\n * @param options - The options.\n * @param options.struct - The struct that caused the error.\n * @param options.prefix - The prefix to add to the error message.\n * @param options.suffix - The suffix to add to the error message. Defaults to\n * an empty string.\n * @param options.error - The `superstruct` error to wrap.\n * @param options.colorize - Whether to colorize the value. Defaults to `true`.\n * @returns The `SnapsStructError`.\n */\nexport function getError<Type, Schema>({\n  struct,\n  prefix,\n  suffix = '',\n  error,\n  colorize,\n}: GetErrorOptions<Type, Schema>) {\n  return new SnapsStructError(\n    struct,\n    prefix,\n    suffix,\n    error,\n    () => arrayToGenerator(error.failures()),\n    colorize,\n  );\n}\n\n/**\n * A wrapper of `superstruct`'s `create` function that throws a\n * `SnapsStructError` instead of a `StructError`. This is useful for improving\n * the error messages returned by `superstruct`.\n *\n * @param value - The value to validate.\n * @param struct - The `superstruct` struct to validate the value against.\n * @param prefix - The prefix to add to the error message.\n * @param suffix - The suffix to add to the error message. Defaults to an empty\n * string.\n * @returns The validated value.\n */\nexport function createFromStruct<Type, Schema>(\n  value: unknown,\n  struct: Struct<Type, Schema>,\n  prefix: string,\n  suffix = '',\n) {\n  try {\n    return create(value, struct);\n  } catch (error) {\n    if (error instanceof StructError) {\n      throw getError({ struct, prefix, suffix, error });\n    }\n\n    throw error;\n  }\n}\n\n/**\n * Get a struct from a failure path.\n *\n * @param struct - The struct.\n * @param path - The failure path.\n * @returns The struct at the failure path.\n */\nexport function getStructFromPath<Type, Schema>(\n  struct: Struct<Type, Schema>,\n  path: string[],\n) {\n  return path.reduce<AnyStruct>((result, key) => {\n    if (isObject(struct.schema) && struct.schema[key]) {\n      return struct.schema[key] as AnyStruct;\n    }\n\n    return result;\n  }, struct);\n}\n\n/**\n * Get the union struct names from a struct.\n *\n * @param struct - The struct.\n * @param colorize - Whether to colorize the value. Defaults to `true`.\n * @returns The union struct names, or `null` if the struct is not a union\n * struct.\n */\nexport function getUnionStructNames<Type, Schema>(\n  struct: Struct<Type, Schema>,\n  colorize = true,\n) {\n  if (Array.isArray(struct.schema)) {\n    return struct.schema.map(({ type }) => color(type, green, colorize));\n  }\n\n  return null;\n}\n\n/**\n * Get an error prefix from a `superstruct` failure. This is useful for\n * formatting the error message returned by `superstruct`.\n *\n * @param failure - The `superstruct` failure.\n * @param colorize - Whether to colorize the value. Defaults to `true`.\n * @returns The error prefix.\n */\nexport function getStructErrorPrefix(failure: Failure, colorize = true) {\n  if (failure.type === 'never' || failure.path.length === 0) {\n    return '';\n  }\n\n  return `At path: ${color(failure.path.join('.'), bold, colorize)} — `;\n}\n\n/**\n * Get a string describing the failure. This is similar to the `message`\n * property of `superstruct`'s `Failure` type, but formats the value in a more\n * readable way.\n *\n * @param struct - The struct that caused the failure.\n * @param failure - The `superstruct` failure.\n * @param colorize - Whether to colorize the value. Defaults to `true`.\n * @returns A string describing the failure.\n */\nexport function getStructFailureMessage<Type, Schema>(\n  struct: Struct<Type, Schema>,\n  failure: Failure,\n  colorize = true,\n) {\n  const received = color(JSON.stringify(failure.value), red, colorize);\n  const prefix = getStructErrorPrefix(failure, colorize);\n\n  if (failure.type === 'union') {\n    const childStruct = getStructFromPath(struct, failure.path);\n    const unionNames = getUnionStructNames(childStruct, colorize);\n\n    if (unionNames) {\n      return `${prefix}Expected the value to be one of: ${unionNames.join(\n        ', ',\n      )}, but received: ${received}.`;\n    }\n\n    return `${prefix}${failure.message}.`;\n  }\n\n  if (failure.type === 'literal') {\n    // Superstruct's failure does not provide information about which literal\n    // value was expected, so we need to parse the message to get the literal.\n    const message = failure.message\n      .replace(\n        /the literal `(.+)`,/u,\n        `the value to be \\`${color('$1', green, colorize)}\\`,`,\n      )\n      .replace(\n        /, but received: (.+)/u,\n        `, but received: ${color('$1', red, colorize)}`,\n      );\n\n    return `${prefix}${message}.`;\n  }\n\n  if (failure.type === 'never') {\n    return `Unknown key: ${color(\n      failure.path.join('.'),\n      bold,\n      colorize,\n    )}, received: ${received}.`;\n  }\n\n  if (failure.refinement === 'size') {\n    const message = failure.message\n      .replace(\n        /length between `(\\d+)` and `(\\d+)`/u,\n        `length between ${color('$1', green, colorize)} and ${color(\n          '$2',\n          green,\n          colorize,\n        )},`,\n      )\n      .replace(/length of `(\\d+)`/u, `length of ${color('$1', red, colorize)}`)\n      .replace(/a array/u, 'an array');\n\n    return `${prefix}${message}.`;\n  }\n\n  return `${prefix}Expected a value of type ${color(\n    failure.type,\n    green,\n    colorize,\n  )}, but received: ${received}.`;\n}\n\n/**\n * Get a string describing the errors. This formats all the errors in a\n * human-readable way.\n *\n * @param struct - The struct that caused the failures.\n * @param failures - The `superstruct` failures.\n * @param colorize - Whether to colorize the value. Defaults to `true`.\n * @returns A string describing the errors.\n */\nexport function getStructErrorMessage<Type, Schema>(\n  struct: Struct<Type, Schema>,\n  failures: Failure[],\n  colorize = true,\n) {\n  const formattedFailures = failures.map((failure) =>\n    indent(`• ${getStructFailureMessage(struct, failure, colorize)}`),\n  );\n\n  return formattedFailures.join('\\n');\n}\n\n/**\n * Validate a union struct, and throw readable errors if the value does not\n * satisfy the struct. This is useful for improving the error messages returned\n * by `superstruct`.\n *\n * @param value - The value to validate.\n * @param struct - The `superstruct` union struct to validate the value against.\n * This struct must be a union of object structs, and must have at least one\n * shared key to validate against.\n * @param structKey - The key to validate against. This key must be present in\n * all the object structs in the union struct, and is expected to be a literal\n * value.\n * @param coerce - Whether to coerce the value to satisfy the struct. Defaults\n * to `false`.\n * @returns The validated value.\n * @throws If the value does not satisfy the struct.\n * @example\n * const struct = union([\n *   object({ type: literal('a'), value: string() }),\n *   object({ type: literal('b'), value: number() }),\n *   object({ type: literal('c'), value: boolean() }),\n *   // ...\n * ]);\n *\n * // At path: type — Expected the value to be one of: \"a\", \"b\", \"c\", but received: \"d\".\n * validateUnion({ type: 'd', value: 'foo' }, struct, 'type');\n *\n * // At path: value — Expected a value of type string, but received: 42.\n * validateUnion({ type: 'a', value: 42 }, struct, 'value');\n */\nexport function validateUnion<Type, Schema extends readonly Struct<any, any>[]>(\n  value: unknown,\n  struct: Struct<Type, Schema>,\n  structKey: keyof Type,\n  coerce = false,\n) {\n  assert(\n    struct.schema,\n    'Expected a struct with a schema. Make sure to use `union` from `@metamask/snaps-sdk`.',\n  );\n  assert(struct.schema.length > 0, 'Expected a non-empty array of structs.');\n\n  const keyUnion = struct.schema.map(\n    (innerStruct) => innerStruct.schema[structKey],\n    // This is guaranteed to be a non-empty array by the assertion above. We\n    // need to cast it since `superstruct` requires a non-empty array of structs\n    // for the `union` struct.\n  ) as NonEmptyArray<Struct>;\n\n  const key = superstructType({\n    [structKey]: union(keyUnion),\n  });\n\n  const [keyError] = validate(value, key, { coerce });\n  if (keyError) {\n    throw new Error(\n      getStructFailureMessage(key, keyError.failures()[0], false),\n    );\n  }\n\n  // At this point it's guaranteed that the value is an object, so we can safely\n  // cast it to a Record.\n  const objectValue = value as Record<PropertyKey, unknown>;\n  const objectStructs = struct.schema.filter((innerStruct) =>\n    is(objectValue[structKey], innerStruct.schema[structKey]),\n  );\n\n  assert(objectStructs.length > 0, 'Expected a struct to match the value.');\n\n  // We need to validate the value against all the object structs that match the\n  // struct key, and return the first validated value.\n  const validationResults = objectStructs.map((objectStruct) =>\n    validate(objectValue, objectStruct, { coerce }),\n  );\n\n  const validatedValue = validationResults.find(([error]) => !error);\n  if (validatedValue) {\n    return validatedValue[1];\n  }\n\n  assert(validationResults[0][0], 'Expected at least one error.');\n\n  // If there is no validated value, we need to find the error with the least\n  // number of failures (with the assumption that it's the most specific error).\n  const validationError = validationResults.reduce((error, [innerError]) => {\n    assert(innerError, 'Expected an error.');\n    if (innerError.failures().length < error.failures().length) {\n      return innerError;\n    }\n\n    return error;\n  }, validationResults[0][0]);\n\n  throw new Error(\n    getStructFailureMessage(struct, validationError.failures()[0], false),\n  );\n}\n\n/**\n * Create a value with the coercion logic of a union struct, and throw readable\n * errors if the value does not satisfy the struct. This is useful for improving\n * the error messages returned by `superstruct`.\n *\n * @param value - The value to validate.\n * @param struct - The `superstruct` union struct to validate the value against.\n * This struct must be a union of object structs, and must have at least one\n * shared key to validate against.\n * @param structKey - The key to validate against. This key must be present in\n * all the object structs in the union struct, and is expected to be a literal\n * value.\n * @returns The validated value.\n * @throws If the value does not satisfy the struct.\n * @see validateUnion\n */\nexport function createUnion<Type, Schema extends readonly Struct<any, any>[]>(\n  value: unknown,\n  struct: Struct<Type, Schema>,\n  structKey: keyof Type,\n) {\n  return validateUnion(value, struct, structKey, true);\n}\n"],"mappings":"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","names":[]}