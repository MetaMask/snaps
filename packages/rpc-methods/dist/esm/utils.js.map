{"version":3,"sources":["../../src/utils.ts"],"sourcesContent":["import type {\n  HardenedBIP32Node,\n  BIP32Node,\n  SLIP10PathNode,\n} from '@metamask/key-tree';\nimport { SLIP10Node } from '@metamask/key-tree';\nimport type { MagicValue } from '@metamask/snaps-utils';\nimport type { Hex } from '@metamask/utils';\nimport {\n  add0x,\n  assert,\n  concatBytes,\n  createDataView,\n  stringToBytes,\n} from '@metamask/utils';\nimport { keccak_256 as keccak256 } from '@noble/hashes/sha3';\n\nconst HARDENED_VALUE = 0x80000000;\n\n/**\n * Maps an interface with method hooks to an object, using the keys of the\n * interface, and `true` as value. This ensures that the `methodHooks` object\n * has the same values as the interface.\n */\nexport type MethodHooksObject<HooksType extends Record<string, unknown>> = {\n  [Key in keyof HooksType]: true;\n};\n\n/**\n * Returns the subset of the specified `hooks` that are included in the\n * `hookNames` object. This is a Principle of Least Authority (POLA) measure\n * to ensure that each RPC method implementation only has access to the\n * API \"hooks\" it needs to do its job.\n *\n * @param hooks - The hooks to select from.\n * @param hookNames - The names of the hooks to select.\n * @returns The selected hooks.\n * @template Hooks - The hooks to select from.\n * @template HookName - The names of the hooks to select.\n */\nexport function selectHooks<\n  Hooks extends Record<string, unknown>,\n  HookName extends keyof Hooks,\n>(\n  hooks: Hooks,\n  hookNames?: Record<HookName, boolean>,\n): Pick<Hooks, HookName> | undefined {\n  if (hookNames) {\n    return Object.keys(hookNames).reduce<Partial<Pick<Hooks, HookName>>>(\n      (hookSubset, _hookName) => {\n        const hookName = _hookName as HookName;\n        hookSubset[hookName] = hooks[hookName];\n        return hookSubset;\n      },\n      {},\n    ) as Pick<Hooks, HookName>;\n  }\n  return undefined;\n}\n\n/**\n * Get a BIP-32 derivation path array from a hash, which is compatible with\n * `@metamask/key-tree`. The hash is assumed to be 32 bytes long.\n *\n * @param hash - The hash to derive indices from.\n * @returns The derived indices as a {@link HardenedBIP32Node} array.\n */\nfunction getDerivationPathArray(hash: Uint8Array): HardenedBIP32Node[] {\n  const array: HardenedBIP32Node[] = [];\n  const view = createDataView(hash);\n\n  for (let index = 0; index < 8; index++) {\n    const uint32 = view.getUint32(index * 4);\n\n    // This is essentially `index | 0x80000000`. Because JavaScript numbers are\n    // signed, we use the bitwise unsigned right shift operator to ensure that\n    // the result is a positive number.\n    // eslint-disable-next-line no-bitwise\n    const pathIndex = (uint32 | HARDENED_VALUE) >>> 0;\n    array.push(`bip32:${pathIndex - HARDENED_VALUE}'` as const);\n  }\n\n  return array;\n}\n\ntype DeriveEntropyOptions = {\n  /**\n   * The input value to derive entropy from.\n   */\n  input: string;\n\n  /**\n   * An optional salt to use when deriving entropy.\n   */\n  salt?: string;\n\n  /**\n   * The mnemonic phrase to use for entropy derivation.\n   */\n  mnemonicPhrase: Uint8Array;\n\n  /**\n   * A hardened BIP-32 index, which is used to derive the root key from the\n   * mnemonic phrase.\n   */\n  magic: MagicValue;\n};\n\n/**\n * Derive entropy from the given mnemonic phrase and salt.\n *\n * This is based on the reference implementation of\n * [SIP-6](https://metamask.github.io/SIPs/SIPS/sip-6).\n *\n * @param options - The options for entropy derivation.\n * @param options.input - The input value to derive entropy from.\n * @param options.salt - An optional salt to use when deriving entropy.\n * @param options.mnemonicPhrase - The mnemonic phrase to use for entropy\n * derivation.\n * @param options.magic - A hardened BIP-32 index, which is used to derive the\n * root key from the mnemonic phrase.\n * @returns The derived entropy.\n */\nexport async function deriveEntropy({\n  input,\n  salt = '',\n  mnemonicPhrase,\n  magic,\n}: DeriveEntropyOptions): Promise<Hex> {\n  const inputBytes = stringToBytes(input);\n  const saltBytes = stringToBytes(salt);\n\n  // Get the derivation path from the snap ID.\n  const hash = keccak256(concatBytes([inputBytes, keccak256(saltBytes)]));\n  const computedDerivationPath = getDerivationPathArray(hash);\n\n  // Derive the private key using BIP-32.\n  const { privateKey } = await SLIP10Node.fromDerivationPath({\n    derivationPath: [\n      mnemonicPhrase,\n      `bip32:${magic}`,\n      ...computedDerivationPath,\n    ],\n    curve: 'secp256k1',\n  });\n\n  // This should never happen, but this keeps TypeScript happy.\n  assert(privateKey, 'Failed to derive the entropy.');\n\n  return add0x(privateKey);\n}\n\n/**\n * Get the path prefix to use for key derivation in `key-tree`. This assumes the\n * following:\n *\n * - The Secp256k1 curve always use the BIP-32 specification.\n * - The Ed25519 curve always use the SLIP-10 specification.\n *\n * While this does not matter in most situations (no known case at the time of\n * writing), `key-tree` requires a specific specification to be used.\n *\n * @param curve - The curve to get the path prefix for. The curve is NOT\n * validated by this function.\n * @returns The path prefix, i.e., `secp256k1` or `ed25519`.\n */\nexport function getPathPrefix(\n  curve: 'secp256k1' | 'ed25519',\n): 'bip32' | 'slip10' {\n  if (curve === 'secp256k1') {\n    return 'bip32';\n  }\n\n  return 'slip10';\n}\n\ntype GetNodeArgs = {\n  curve: 'secp256k1' | 'ed25519';\n  secretRecoveryPhrase: Uint8Array;\n  path: string[];\n};\n\n/**\n * Get a `key-tree`-compatible node.\n *\n * Note: This function assumes that all the parameters have been validated\n * beforehand.\n *\n * @param options - The derivation options.\n * @param options.curve - The curve to use for derivation.\n * @param options.secretRecoveryPhrase - The secret recovery phrase to use for\n * derivation.\n * @param options.path - The derivation path to use as array, starting with an\n * \"m\" as the first item.\n */\nexport async function getNode({\n  curve,\n  secretRecoveryPhrase,\n  path,\n}: GetNodeArgs) {\n  const prefix = getPathPrefix(curve);\n  return await SLIP10Node.fromDerivationPath({\n    curve,\n    derivationPath: [\n      secretRecoveryPhrase,\n      ...(path.slice(1).map((index) => `${prefix}:${index}`) as\n        | BIP32Node[]\n        | SLIP10PathNode[]),\n    ],\n  });\n}\n"],"names":["SLIP10Node","add0x","assert","concatBytes","createDataView","stringToBytes","keccak_256","keccak256","HARDENED_VALUE","selectHooks","hooks","hookNames","Object","keys","reduce","hookSubset","_hookName","hookName","undefined","getDerivationPathArray","hash","array","view","index","uint32","getUint32","pathIndex","push","deriveEntropy","input","salt","mnemonicPhrase","magic","inputBytes","saltBytes","computedDerivationPath","privateKey","fromDerivationPath","derivationPath","curve","getPathPrefix","getNode","secretRecoveryPhrase","path","prefix","slice","map"],"mappings":"AAKA,SAASA,UAAU,QAAQ,qBAAqB;AAGhD,SACEC,KAAK,EACLC,MAAM,EACNC,WAAW,EACXC,cAAc,EACdC,aAAa,QACR,kBAAkB;AACzB,SAASC,cAAcC,SAAS,QAAQ,qBAAqB;AAE7D,MAAMC,iBAAiB;AAWvB;;;;;;;;;;;CAWC,GACD,OAAO,SAASC,YAIdC,KAAY,EACZC,SAAqC;IAErC,IAAIA,WAAW;QACb,OAAOC,OAAOC,IAAI,CAACF,WAAWG,MAAM,CAClC,CAACC,YAAYC;YACX,MAAMC,WAAWD;YACjBD,UAAU,CAACE,SAAS,GAAGP,KAAK,CAACO,SAAS;YACtC,OAAOF;QACT,GACA,CAAC;IAEL;IACA,OAAOG;AACT;AAEA;;;;;;CAMC,GACD,SAASC,uBAAuBC,IAAgB;IAC9C,MAAMC,QAA6B,EAAE;IACrC,MAAMC,OAAOlB,eAAegB;IAE5B,IAAK,IAAIG,QAAQ,GAAGA,QAAQ,GAAGA,QAAS;QACtC,MAAMC,SAASF,KAAKG,SAAS,CAACF,QAAQ;QAEtC,2EAA2E;QAC3E,0EAA0E;QAC1E,mCAAmC;QACnC,sCAAsC;QACtC,MAAMG,YAAY,AAACF,CAAAA,SAAShB,cAAa,MAAO;QAChDa,MAAMM,IAAI,CAAC,CAAC,MAAM,EAAED,YAAYlB,eAAe,CAAC,CAAC;IACnD;IAEA,OAAOa;AACT;AAyBA;;;;;;;;;;;;;;CAcC,GACD,OAAO,eAAeO,cAAc,EAClCC,KAAK,EACLC,OAAO,EAAE,EACTC,cAAc,EACdC,KAAK,EACgB;IACrB,MAAMC,aAAa5B,cAAcwB;IACjC,MAAMK,YAAY7B,cAAcyB;IAEhC,4CAA4C;IAC5C,MAAMV,OAAOb,UAAUJ,YAAY;QAAC8B;QAAY1B,UAAU2B;KAAW;IACrE,MAAMC,yBAAyBhB,uBAAuBC;IAEtD,uCAAuC;IACvC,MAAM,EAAEgB,UAAU,EAAE,GAAG,MAAMpC,WAAWqC,kBAAkB,CAAC;QACzDC,gBAAgB;YACdP;YACA,CAAC,MAAM,EAAEC,MAAM,CAAC;eACbG;SACJ;QACDI,OAAO;IACT;IAEA,6DAA6D;IAC7DrC,OAAOkC,YAAY;IAEnB,OAAOnC,MAAMmC;AACf;AAEA;;;;;;;;;;;;;CAaC,GACD,OAAO,SAASI,cACdD,KAA8B;IAE9B,IAAIA,UAAU,aAAa;QACzB,OAAO;IACT;IAEA,OAAO;AACT;AAQA;;;;;;;;;;;;CAYC,GACD,OAAO,eAAeE,QAAQ,EAC5BF,KAAK,EACLG,oBAAoB,EACpBC,IAAI,EACQ;IACZ,MAAMC,SAASJ,cAAcD;IAC7B,OAAO,MAAMvC,WAAWqC,kBAAkB,CAAC;QACzCE;QACAD,gBAAgB;YACdI;eACIC,KAAKE,KAAK,CAAC,GAAGC,GAAG,CAAC,CAACvB,QAAU,CAAC,EAAEqB,OAAO,CAAC,EAAErB,MAAM,CAAC;SAGtD;IACH;AACF"}