{"version":3,"sources":["../src/helpers.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;AAEA,SAAS,kBAAkB;AAE3B,SAAS,aAAa,gBAAgB,eAAe;AACrD,SAAS,cAAc;AACvB;AAAA,EACE;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,OACK;AAmCP,IAAM,MAAM,mBAAmB,YAAY,SAAS;AASpD,SAAS,WAKP,QACA,SAC4D;AAC5D,MAAI,OAAO,WAAW,UAAU;AAC9B,WAAO,CAAC,QAAW,MAAM;AAAA,EAC3B;AAEA,SAAO,CAAC,QAAQ,OAAO;AACzB;AAOA,SAAS,8BACP,UAC+C;AAC/C,eAAa,UAAU,+BAA+B;AACxD;AAOO,SAAS,oBACd,IACyD;AACzD,SAAO,YAAY,IAAI,MAAM,KAAK,GAAG,SAAS,WAAW,KAAK;AAChE;AAOO,SAAS,2BACd,IACgE;AAChE,SAAO,YAAY,IAAI,MAAM,KAAK,GAAG,SAAS,WAAW,YAAY;AACvE;AAOO,SAAS,qBACd,IAC0D;AAC1D,SAAO,YAAY,IAAI,MAAM,KAAK,GAAG,SAAS,WAAW,MAAM;AACjE;AAOO,SAAS,qBACd,IAC2D;AAC3D,SAAO,CAAC,YAAY,IAAI,MAAM,CAAC;AACjC;AAOO,SAAS,4BACd,IACqE;AACrE,QAAM,SAAS,iBAAgC,GAAG,SAAS,QAAQ;AAEnE,SAAO,UAAU,eAAe,MAAM,EAAE,WAAW,CAAC;AACtD;AAOO,SAAS,mCACd,IAC4E;AAC5E,QAAM,SAAS,iBAAgC,GAAG,SAAS,QAAQ;AAEnE,SAAO,UAAU,eAAe,MAAM,EAAE,WAAW,CAAC;AACtD;AAOO,SAAS,8BACd,IACwE;AACxE,QAAM,SAAS,iBAAgC,GAAG,SAAS,QAAQ;AAEnE,SAAO,CAAC,MAAM;AAChB;AAqIA,eAAsB,YAKpB,QACA,UAAgD,CAAC,GAClC;AACf,QAAM,kBAAkB,WAAW,QAAQ,OAAO;AAClD,QAAM;AAAA,IACJ,QAAQ;AAAA,IACR;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,IAAI,MAAM,eAAe,EAAE,YAAY,GAAG,eAAe;AAEzD,QAAM,gBAAgB,OACpB,YACuC;AACvC,QAAI,2BAA2B,OAAO;AAEtC,UAAM;AAAA,MACJ,QAAQ;AAAA,MACR;AAAA,MACA,GAAG;AAAA,IACL,IAAI,OAAO,SAAS,wBAAwB;AAE5C,UAAM,WAAW,MAAM,cAAc;AAAA,MACnC,QAAQ;AAAA,MACR;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA,SAAS,YAAY;AAAA,MACrB,SAAS;AAAA,QACP,QAAQ;AAAA,QACR,QAAQ;AAAA,UACN;AAAA,UACA;AAAA,UACA;AAAA,QACF;AAAA,MACF;AAAA,IACF,CAAC;AAED,kCAA8B,QAAQ;AAEtC,WAAO;AAAA,EACT;AAEA,QAAM,YAAY,CAAC,YAA4B;AAC7C,QAAI,uBAAuB,OAAO;AAElC,WAAO,cAAc;AAAA,MACnB,QAAQ;AAAA,MACR;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA,SAAS,YAAY;AAAA,MACrB;AAAA,IACF,CAAC;AAAA,EACH;AAEA,SAAO;AAAA,IACL,SAAS,CAAC,YAAY;AACpB,UAAI,uBAAuB,OAAO;AAElC,aAAO,cAAc;AAAA,QACnB,QAAQ;AAAA,QACR;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA,SAAS,YAAY;AAAA,QACrB;AAAA,MACF,CAAC;AAAA,IACH;AAAA,IAEA;AAAA,IACA,iBAAiB;AAAA,IAEjB,aAAa,OACX,YACuC;AACvC,UAAI,4BAA4B,OAAO;AAEvC,YAAM,EAAE,QAAQ,iBAAiB,GAAG,UAAU,IAAI;AAAA,QAChD;AAAA,QACA;AAAA,MACF;AAEA,YAAM,WAAW,MAAM,cAAc;AAAA,QACnC,QAAQ;AAAA,QACR;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA,SAAS,YAAY;AAAA,QACrB,SAAS;AAAA,UACP,QAAQ;AAAA,UACR,QAAQ;AAAA,YACN;AAAA,YACA;AAAA,UACF;AAAA,QACF;AAAA,MACF,CAAC;AAED,oCAA8B,QAAQ;AAEtC,aAAO;AAAA,IACT;AAAA,IAEA;AAAA,IACA,YAAY;AAAA,IAEZ,YAAY,YAAgD;AAC1D,UAAI,sBAAsB;AAE1B,YAAM,WAAW,MAAM,cAAc;AAAA,QACnC,QAAQ;AAAA,QACR;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA,SAAS,YAAY;AAAA,QACrB,SAAS;AAAA,UACP,QAAQ;AAAA,QACV;AAAA,MACF,CAAC;AAED,oCAA8B,QAAQ;AAEtC,aAAO;AAAA,IACT;AAAA,IAEA,YAAY,MAA0B;AACpC,UAAI,gCAAgC,IAAI;AAExC,YAAM,EAAE,QAAQ,OAAO,IAAI,OAAO,MAAM,wBAAwB;AAChE,YAAM,SAAS,eAAe,EAAE,QAAQ,OAAO,CAAC,CAAC;AAEjD,aAAO;AAAA,QACL,SAAS;AACP,cAAI,kCAAkC,IAAI;AAE1C,gBAAM,SAAS,kBAAkB,MAAM,CAAC;AAAA,QAC1C;AAAA,MACF;AAAA,IACF;AAAA,IAEA,OAAO,YAAY;AACjB,UAAI,4BAA4B;AAChC;AAAA,QACE;AAAA,MACF;AAEA,YAAM,iBAAiB,kBAAkB;AAAA,IAC3C;AAAA,EACF;AACF","sourcesContent":["import type { AbstractExecutionService } from '@metamask/snaps-controllers';\nimport type { SnapId } from '@metamask/snaps-sdk';\nimport { DialogType } from '@metamask/snaps-sdk';\nimport type { FooterElement } from '@metamask/snaps-sdk/jsx';\nimport { HandlerType, getJsxChildren, logInfo } from '@metamask/snaps-utils';\nimport { create } from '@metamask/superstruct';\nimport {\n  assert,\n  assertStruct,\n  createModuleLogger,\n  hasProperty,\n} from '@metamask/utils';\n\nimport {\n  rootLogger,\n  handleRequest,\n  TransactionOptionsStruct,\n  getEnvironment,\n  JsonRpcMockOptionsStruct,\n  SignatureOptionsStruct,\n  SnapResponseWithInterfaceStruct,\n  getElementByType,\n} from './internals';\nimport type { InstallSnapOptions } from './internals';\nimport {\n  addJsonRpcMock,\n  removeJsonRpcMock,\n} from './internals/simulation/store/mocks';\nimport type {\n  SnapResponseWithInterface,\n  CronjobOptions,\n  JsonRpcMockOptions,\n  Snap,\n  SnapResponse,\n  TransactionOptions,\n  SnapInterface,\n  SnapAlertInterface,\n  SnapInterfaceActions,\n  SnapConfirmationInterface,\n  SnapPromptInterface,\n  DefaultSnapInterface,\n  DefaultSnapInterfaceWithFooter,\n  DefaultSnapInterfaceWithPartialFooter,\n  DefaultSnapInterfaceWithoutFooter,\n} from './types';\n\nconst log = createModuleLogger(rootLogger, 'helpers');\n\n/**\n * Get the options for {@link installSnap}.\n *\n * @param snapId - The ID of the Snap, or the options.\n * @param options - The options, if any.\n * @returns The options.\n */\nfunction getOptions<\n  Service extends new (...args: any[]) => InstanceType<\n    typeof AbstractExecutionService\n  >,\n>(\n  snapId: SnapId | Partial<InstallSnapOptions<Service>> | undefined,\n  options: Partial<InstallSnapOptions<Service>>,\n): [SnapId | undefined, Partial<InstallSnapOptions<Service>>] {\n  if (typeof snapId === 'object') {\n    return [undefined, snapId];\n  }\n\n  return [snapId, options];\n}\n\n/**\n * Ensure that the actual response contains `getInterface`.\n *\n * @param response - The response of the handler.\n */\nfunction assertIsResponseWithInterface(\n  response: SnapResponse,\n): asserts response is SnapResponseWithInterface {\n  assertStruct(response, SnapResponseWithInterfaceStruct);\n}\n\n/**\n * Ensure that the actual interface is an alert dialog.\n *\n * @param ui - The interface to verify.\n */\nexport function assertIsAlertDialog(\n  ui: SnapInterface,\n): asserts ui is SnapAlertInterface & SnapInterfaceActions {\n  assert(hasProperty(ui, 'type') && ui.type === DialogType.Alert);\n}\n\n/**\n * Ensure that the actual interface is a confirmation dialog.\n *\n * @param ui - The interface to verify.\n */\nexport function assertIsConfirmationDialog(\n  ui: SnapInterface,\n): asserts ui is SnapConfirmationInterface & SnapInterfaceActions {\n  assert(hasProperty(ui, 'type') && ui.type === DialogType.Confirmation);\n}\n\n/**\n * Ensure that the actual interface is a Prompt dialog.\n *\n * @param ui - The interface to verify.\n */\nexport function assertIsPromptDialog(\n  ui: SnapInterface,\n): asserts ui is SnapPromptInterface & SnapInterfaceActions {\n  assert(hasProperty(ui, 'type') && ui.type === DialogType.Prompt);\n}\n\n/**\n * Ensure that the actual interface is a custom dialog.\n *\n * @param ui - The interface to verify.\n */\nexport function assertIsCustomDialog(\n  ui: SnapInterface,\n): asserts ui is DefaultSnapInterface & SnapInterfaceActions {\n  assert(!hasProperty(ui, 'type'));\n}\n\n/**\n * Ensure that the actual interface is a custom dialog with a complete footer.\n *\n * @param ui - The interface to verify.\n */\nexport function assertCustomDialogHasFooter(\n  ui: DefaultSnapInterface & SnapInterfaceActions,\n): asserts ui is DefaultSnapInterfaceWithFooter & SnapInterfaceActions {\n  const footer = getElementByType<FooterElement>(ui.content, 'Footer');\n\n  assert(footer && getJsxChildren(footer).length === 2);\n}\n\n/**\n * Ensure that the actual interface is a custom dialog with a partial footer.\n *\n * @param ui - The interface to verify.\n */\nexport function assertCustomDialogHasPartialFooter(\n  ui: DefaultSnapInterface & SnapInterfaceActions,\n): asserts ui is DefaultSnapInterfaceWithPartialFooter & SnapInterfaceActions {\n  const footer = getElementByType<FooterElement>(ui.content, 'Footer');\n\n  assert(footer && getJsxChildren(footer).length === 1);\n}\n\n/**\n * Ensure that the actual interface is a custom dialog without a footer.\n *\n * @param ui - The interface to verify.\n */\nexport function assertCustomDialogHasNoFooter(\n  ui: DefaultSnapInterface & SnapInterfaceActions,\n): asserts ui is DefaultSnapInterfaceWithoutFooter & SnapInterfaceActions {\n  const footer = getElementByType<FooterElement>(ui.content, 'Footer');\n\n  assert(!footer);\n}\n\n/**\n * Load a snap into the environment. This is the main entry point for testing\n * snaps: It returns a {@link Snap} object that can be used to interact with the\n * snap.\n *\n * @example\n * import { installSnap } from '@metamask/snaps-jest';\n *\n * describe('My Snap', () => {\n *   it('should do something', async () => {\n *     const { request } = await installSnap('local:my-snap');\n *     const response = await request({\n *       method: 'foo',\n *       params: ['bar'],\n *     });\n *     expect(response).toRespondWith('bar');\n *   });\n * });\n * @returns The snap.\n * @throws If the built-in server is not running, and no snap ID is provided.\n */\nexport async function installSnap(): Promise<Snap>;\n\n/**\n * Load a snap into the environment. This is the main entry point for testing\n * snaps: It returns a {@link Snap} object that can be used to interact with the\n * snap.\n *\n * @example\n * import { installSnap } from '@metamask/snaps-jest';\n *\n * describe('My Snap', () => {\n *   it('should do something', async () => {\n *     const { request } = await installSnap('local:my-snap');\n *     const response = await request({\n *       method: 'foo',\n *       params: ['bar'],\n *     });\n *     expect(response).toRespondWith('bar');\n *   });\n * });\n * @param options - The options to use.\n * @param options.executionService - The execution service to use. Defaults to\n * {@link NodeThreadExecutionService}. You do not need to provide this unless\n * you are testing a custom execution service.\n * @param options.executionServiceOptions - The options to use when creating the\n * execution service, if any. This should only include options specific to the\n * provided execution service.\n * @param options.options - The simulation options.\n * @returns The snap.\n * @throws If the built-in server is not running, and no snap ID is provided.\n */\nexport async function installSnap<\n  Service extends new (...args: any[]) => InstanceType<\n    typeof AbstractExecutionService\n  >,\n>(options: Partial<InstallSnapOptions<Service>>): Promise<Snap>;\n\n/**\n * Load a snap into the environment. This is the main entry point for testing\n * snaps: It returns a {@link Snap} object that can be used to interact with the\n * snap.\n *\n * @example\n * import { installSnap } from '@metamask/snaps-jest';\n *\n * describe('My Snap', () => {\n *   it('should do something', async () => {\n *     const { request } = await installSnap('local:my-snap');\n *     const response = await request({\n *       method: 'foo',\n *       params: ['bar'],\n *     });\n *     expect(response).toRespondWith('bar');\n *   });\n * });\n * @param snapId - The ID of the snap, including the prefix (`local:`). Defaults\n * to the URL of the built-in server, if it is running. This supports both\n * local snap IDs and NPM snap IDs.\n * @param options - The options to use.\n * @param options.executionService - The execution service to use. Defaults to\n * {@link NodeThreadExecutionService}. You do not need to provide this unless\n * you are testing a custom execution service.\n * @param options.executionServiceOptions - The options to use when creating the\n * execution service, if any. This should only include options specific to the\n * provided execution service.\n * @param options.options - The simulation options.\n * @returns The snap.\n * @throws If the built-in server is not running, and no snap ID is provided.\n */\nexport async function installSnap<\n  Service extends new (...args: any[]) => InstanceType<\n    typeof AbstractExecutionService\n  >,\n>(\n  snapId: SnapId,\n  options?: Partial<InstallSnapOptions<Service>>,\n): Promise<Snap>;\n\n/**\n * Load a snap into the environment. This is the main entry point for testing\n * snaps: It returns a {@link Snap} object that can be used to interact with the\n * snap.\n *\n * @example\n * import { installSnap } from '@metamask/snaps-jest';\n *\n * describe('My Snap', () => {\n *   it('should do something', async () => {\n *     const { request } = await installSnap('local:my-snap');\n *     const response = await request({\n *       method: 'foo',\n *       params: ['bar'],\n *     });\n *     expect(response).toRespondWith('bar');\n *   });\n * });\n * @param snapId - The ID of the snap, including the prefix (`local:`). Defaults\n * to the URL of the built-in server, if it is running. This supports both\n * local snap IDs and NPM snap IDs.\n * @param options - The options to use.\n * @param options.executionService - The execution service to use. Defaults to\n * {@link NodeThreadExecutionService}. You do not need to provide this unless\n * you are testing a custom execution service.\n * @param options.executionServiceOptions - The options to use when creating the\n * execution service, if any. This should only include options specific to the\n * provided execution service.\n * @param options.options - The simulation options.\n * @returns The snap.\n * @throws If the built-in server is not running, and no snap ID is provided.\n */\nexport async function installSnap<\n  Service extends new (...args: any[]) => InstanceType<\n    typeof AbstractExecutionService\n  >,\n>(\n  snapId?: SnapId | Partial<InstallSnapOptions<Service>>,\n  options: Partial<InstallSnapOptions<Service>> = {},\n): Promise<Snap> {\n  const resolvedOptions = getOptions(snapId, options);\n  const {\n    snapId: installedSnapId,\n    store,\n    executionService,\n    runSaga,\n    controllerMessenger,\n  } = await getEnvironment().installSnap(...resolvedOptions);\n\n  const onTransaction = async (\n    request: TransactionOptions,\n  ): Promise<SnapResponseWithInterface> => {\n    log('Sending transaction %o.', request);\n\n    const {\n      origin: transactionOrigin,\n      chainId,\n      ...transaction\n    } = create(request, TransactionOptionsStruct);\n\n    const response = await handleRequest({\n      snapId: installedSnapId,\n      store,\n      executionService,\n      runSaga,\n      controllerMessenger,\n      handler: HandlerType.OnTransaction,\n      request: {\n        method: '',\n        params: {\n          chainId,\n          transaction,\n          transactionOrigin,\n        },\n      },\n    });\n\n    assertIsResponseWithInterface(response);\n\n    return response;\n  };\n\n  const onCronjob = (request: CronjobOptions) => {\n    log('Running cronjob %o.', options);\n\n    return handleRequest({\n      snapId: installedSnapId,\n      store,\n      executionService,\n      controllerMessenger,\n      runSaga,\n      handler: HandlerType.OnCronjob,\n      request,\n    });\n  };\n\n  return {\n    request: (request) => {\n      log('Sending request %o.', request);\n\n      return handleRequest({\n        snapId: installedSnapId,\n        store,\n        executionService,\n        controllerMessenger,\n        runSaga,\n        handler: HandlerType.OnRpcRequest,\n        request,\n      });\n    },\n\n    onTransaction,\n    sendTransaction: onTransaction,\n\n    onSignature: async (\n      request: unknown,\n    ): Promise<SnapResponseWithInterface> => {\n      log('Requesting signature %o.', request);\n\n      const { origin: signatureOrigin, ...signature } = create(\n        request,\n        SignatureOptionsStruct,\n      );\n\n      const response = await handleRequest({\n        snapId: installedSnapId,\n        store,\n        executionService,\n        controllerMessenger,\n        runSaga,\n        handler: HandlerType.OnSignature,\n        request: {\n          method: '',\n          params: {\n            signature,\n            signatureOrigin,\n          },\n        },\n      });\n\n      assertIsResponseWithInterface(response);\n\n      return response;\n    },\n\n    onCronjob,\n    runCronjob: onCronjob,\n\n    onHomePage: async (): Promise<SnapResponseWithInterface> => {\n      log('Rendering home page.');\n\n      const response = await handleRequest({\n        snapId: installedSnapId,\n        store,\n        executionService,\n        controllerMessenger,\n        runSaga,\n        handler: HandlerType.OnHomePage,\n        request: {\n          method: '',\n        },\n      });\n\n      assertIsResponseWithInterface(response);\n\n      return response;\n    },\n\n    mockJsonRpc(mock: JsonRpcMockOptions) {\n      log('Mocking JSON-RPC request %o.', mock);\n\n      const { method, result } = create(mock, JsonRpcMockOptionsStruct);\n      store.dispatch(addJsonRpcMock({ method, result }));\n\n      return {\n        unmock() {\n          log('Unmocking JSON-RPC request %o.', mock);\n\n          store.dispatch(removeJsonRpcMock(method));\n        },\n      };\n    },\n\n    close: async () => {\n      log('Closing execution service.');\n      logInfo(\n        'Calling `snap.close()` is deprecated, and will be removed in a future release. Snaps are now automatically closed when the test ends.',\n      );\n\n      await executionService.terminateAllSnaps();\n    },\n  };\n}\n"]}