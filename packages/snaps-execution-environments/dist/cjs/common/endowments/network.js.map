{"version":3,"sources":["../../../../src/common/endowments/network.ts"],"sourcesContent":["import { withTeardown } from '../utils';\n\n/**\n * This class wraps a Response object.\n * That way, a teardown process can stop any processes left.\n */\nclass ResponseWrapper implements Response {\n  readonly #teardownRef: { lastTeardown: number };\n\n  #ogResponse: Response;\n\n  constructor(ogResponse: Response, teardownRef: { lastTeardown: number }) {\n    this.#ogResponse = ogResponse;\n    this.#teardownRef = teardownRef;\n  }\n\n  get body(): ReadableStream<Uint8Array> | null {\n    return this.#ogResponse.body;\n  }\n\n  get bodyUsed() {\n    return this.#ogResponse.bodyUsed;\n  }\n\n  get headers() {\n    return this.#ogResponse.headers;\n  }\n\n  get ok() {\n    return this.#ogResponse.ok;\n  }\n\n  get redirected() {\n    return this.#ogResponse.redirected;\n  }\n\n  get status() {\n    return this.#ogResponse.status;\n  }\n\n  get statusText() {\n    return this.#ogResponse.statusText;\n  }\n\n  get type() {\n    return this.#ogResponse.type;\n  }\n\n  get url() {\n    return this.#ogResponse.url;\n  }\n\n  async text() {\n    return withTeardown<string>(this.#ogResponse.text(), this as any);\n  }\n\n  async arrayBuffer(): Promise<ArrayBuffer> {\n    return withTeardown<ArrayBuffer>(\n      this.#ogResponse.arrayBuffer(),\n      this as any,\n    );\n  }\n\n  async blob(): Promise<Blob> {\n    return withTeardown<Blob>(this.#ogResponse.blob(), this as any);\n  }\n\n  clone(): Response {\n    const newResponse = this.#ogResponse.clone();\n    return new ResponseWrapper(newResponse, this.#teardownRef);\n  }\n\n  async formData(): Promise<FormData> {\n    return withTeardown<FormData>(this.#ogResponse.formData(), this as any);\n  }\n\n  async json(): Promise<any> {\n    return withTeardown(this.#ogResponse.json(), this as any);\n  }\n}\n\n/**\n * Create a network endowment, consisting of a `fetch` function.\n * This allows us to provide a teardown function, so that we can cancel\n * any pending requests, connections, streams, etc. that may be open when a snap\n * is terminated.\n *\n * This wraps the original implementation of `fetch`,\n * to ensure that a bad actor cannot get access to the original function, thus\n * potentially preventing the network requests from being torn down.\n *\n * @returns An object containing a wrapped `fetch`\n * function, as well as a teardown function.\n */\nconst createNetwork = () => {\n  // Open fetch calls or open body streams\n  const openConnections = new Set<{ cancel: () => Promise<void> }>();\n  // Track last teardown count\n  const teardownRef = { lastTeardown: 0 };\n\n  // Remove items from openConnections after they were garbage collected\n  const cleanup = new FinalizationRegistry<() => void>(\n    /* istanbul ignore next: can't test garbage collection without modifying node parameters */\n    (callback) => callback(),\n  );\n\n  const _fetch: typeof fetch = async (\n    input: RequestInfo | URL,\n    init?: RequestInit,\n  ): Promise<Response> => {\n    const abortController = new AbortController();\n    if (init?.signal !== null && init?.signal !== undefined) {\n      const originalSignal = init.signal;\n      // Merge abort controllers\n      originalSignal.addEventListener(\n        'abort',\n        () => {\n          abortController.abort((originalSignal as any).reason);\n        },\n        { once: true },\n      );\n    }\n\n    let res: Response;\n    let openFetchConnection: { cancel: () => Promise<void> } | undefined;\n    try {\n      const fetchPromise = fetch(input, {\n        ...init,\n        signal: abortController.signal,\n      });\n\n      openFetchConnection = {\n        cancel: async () => {\n          abortController.abort();\n          try {\n            await fetchPromise;\n          } catch {\n            /* do nothing */\n          }\n        },\n      };\n      openConnections.add(openFetchConnection);\n\n      res = new ResponseWrapper(\n        await withTeardown(fetchPromise, teardownRef),\n        teardownRef,\n      );\n    } finally {\n      if (openFetchConnection !== undefined) {\n        openConnections.delete(openFetchConnection);\n      }\n    }\n\n    if (res.body !== null) {\n      const body = new WeakRef<ReadableStream>(res.body);\n\n      const openBodyConnection = {\n        cancel:\n          /* istanbul ignore next: see it.todo('can be torn down during body read') test */\n          async () => {\n            try {\n              await body.deref()?.cancel();\n            } catch {\n              /* do nothing */\n            }\n          },\n      };\n      openConnections.add(openBodyConnection);\n      cleanup.register(\n        res.body,\n        /* istanbul ignore next: can't test garbage collection without modifying node parameters */\n        () => openConnections.delete(openBodyConnection),\n      );\n    }\n    return harden(res);\n  };\n\n  const teardownFunction = async () => {\n    teardownRef.lastTeardown += 1;\n    const promises: Promise<void>[] = [];\n    openConnections.forEach(({ cancel }) => promises.push(cancel()));\n    openConnections.clear();\n    await Promise.all(promises);\n  };\n\n  return {\n    fetch: harden(_fetch),\n    // Request, Headers and Response are the endowments injected alongside fetch\n    // only when 'endowment:network-access' permission is requested,\n    // therefore these are hardened as part of fetch dependency injection within its factory.\n    // These endowments are not (and should never be) available by default.\n    Request: harden(Request),\n    Headers: harden(Headers),\n    Response: harden(Response),\n    teardownFunction,\n  };\n};\n\nconst endowmentModule = {\n  names: ['fetch', 'Request', 'Headers', 'Response'] as const,\n  factory: createNetwork,\n};\nexport default endowmentModule;\n"],"names":["ResponseWrapper","body","ogResponse","bodyUsed","headers","ok","redirected","status","statusText","type","url","text","withTeardown","arrayBuffer","blob","clone","newResponse","teardownRef","formData","json","constructor","createNetwork","openConnections","Set","lastTeardown","cleanup","FinalizationRegistry","callback","_fetch","input","init","abortController","AbortController","signal","undefined","originalSignal","addEventListener","abort","reason","once","res","openFetchConnection","fetchPromise","fetch","cancel","add","delete","WeakRef","openBodyConnection","deref","register","harden","teardownFunction","promises","forEach","push","clear","Promise","all","Request","Headers","Response","endowmentModule","names","factory"],"mappings":"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"}