{"version":3,"sources":["../src/snaps/Timer.ts"],"names":[],"mappings":";AAAA,SAAS,cAAc;AAIhB,IAAM,QAAN,MAAY;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAwBjB,YAAY,IAAY;AACtB;AAAA,MACE,CAAC,OAAO,MAAM,EAAE;AAAA,MAChB,IAAI,UAAU,mCAAmC;AAAA,IACnD;AACA,WAAO,MAAM,GAAG,IAAI,UAAU,wCAAwC,CAAC;AACvE,SAAK,QAAQ,EAAE,OAAO,WAAW,WAAW,GAAG;AAAA,EACjD;AAAA,EAEA,IAAI,SAAsB;AACxB,WAAO,KAAK,MAAM;AAAA,EACpB;AAAA,EAEA,IAAI,YAAoB;AACtB,WAAO,KAAK,MAAM;AAAA,EACpB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,SAAS;AACP;AAAA,MACE,KAAK,WAAW,YAAY,KAAK,WAAW;AAAA,MAC5C,IAAI,MAAM,qCAAqC;AAAA,IACjD;AACA,SAAK,SAAS,KAAK;AAAA,EACrB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,SAAS;AACP;AAAA,MACE,KAAK,WAAW;AAAA,MAChB,IAAI,MAAM,mCAAmC;AAAA,IAC/C;AACA,SAAK,SAAS,IAAI;AAAA,EACpB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,QAAQ;AACN;AAAA,MACE,KAAK,MAAM,UAAU;AAAA,MACrB,IAAI,MAAM,oCAAoC;AAAA,IAChD;AAEA,UAAM,EAAE,UAAU,OAAO,SAAS,UAAU,IAAI,KAAK;AAErD,gBAAY,UAAa,aAAa,OAAc;AACpD,SAAK,QAAQ;AAAA,MACX,OAAO;AAAA,MACP;AAAA,MACA,WAAW,aAAa,KAAK,IAAI,IAAI;AAAA,IACvC;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,MAAM,UAAsB;AAC1B;AAAA,MACE,KAAK,MAAM,UAAU;AAAA,MACrB,IAAI,MAAM,yCAAyC;AAAA,IACrD;AAEA,UAAM,EAAE,UAAU,IAAI,KAAK;AAC3B,SAAK,QAAQ,EAAE,OAAO,UAAU,WAAW,SAAS;AACpD,SAAK,OAAO;AAAA,EACd;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,SAAS;AACP;AAAA,MACE,KAAK,MAAM,UAAU;AAAA,MACrB,IAAI,MAAM,kCAAkC;AAAA,IAC9C;AACA,UAAM,EAAE,WAAW,SAAS,IAAI,KAAK;AACrC,UAAM,QAAQ,KAAK,IAAI;AAEvB,QAAI;AAEJ,QAAI,cAAc,OAAO,mBAAmB;AAC1C,gBAAU,WAAW,MAAM,KAAK,SAAS,IAAI,GAAG,SAAS;AAAA,IAC3D;AAEA,SAAK,QAAQ,EAAE,OAAO,WAAW,UAAU,WAAW,OAAO,QAAQ;AAAA,EACvE;AAAA,EAEQ,SAAS,YAAqB;AACpC,WAAO,KAAK,MAAM,UAAU,aAAa,KAAK,MAAM,UAAU,QAAQ;AAEtE,QAAI,KAAK,MAAM,UAAU,aAAa,KAAK,MAAM,YAAY,QAAW;AACtE,mBAAa,KAAK,MAAM,OAAc;AAAA,IACxC;AAEA,UAAM,EAAE,UAAU,UAAU,IAAI,KAAK;AACrC,SAAK,QAAQ;AAAA,MACX,OAAO;AAAA,MACP,WACE,KAAK,MAAM,UAAU,YACjB,aAAa,KAAK,IAAI,IAAI,KAAK,MAAM,SACrC;AAAA,IACR;AAEA,QAAI,YAAY;AACd,eAAS;AAAA,IACX;AAAA,EACF;AACF","sourcesContent":["import { assert } from '@metamask/utils';\n\nexport type TimerStatus = 'stopped' | 'paused' | 'running' | 'finished';\n\nexport class Timer {\n  private state:\n    | { value: 'stopped'; remaining: number }\n    | {\n        value: 'paused';\n        remaining: number;\n        callback: () => void;\n      }\n    | {\n        value: 'running';\n        remaining: number;\n        callback: () => void;\n        start: number;\n        timeout?: unknown;\n      }\n    | { value: 'finished'; remaining: number };\n\n  /**\n   * If `ms` is smaller or equal to zero (including -Infinity), the callback is added to the event loop and executed async immediately\n   * If `ms` is +Infinity the timer never finishes.\n   *\n   * @throws {@link TypeError}. If `ms` is NaN or negative.\n   * @param ms - The number of milliseconds before the callback is called after started.\n   */\n  constructor(ms: number) {\n    assert(\n      !Number.isNaN(ms),\n      new TypeError(\"Can't start a timer with NaN time\"),\n    );\n    assert(ms >= 0, new TypeError(\"Can't start a timer with negative time\"));\n    this.state = { value: 'stopped', remaining: ms };\n  }\n\n  get status(): TimerStatus {\n    return this.state.value;\n  }\n\n  get remaining(): number {\n    return this.state.remaining;\n  }\n\n  /**\n   * Cancels the currently running timer and marks it finished.\n   *\n   * @throws {@link Error}. If it wasn't running or paused.\n   */\n  cancel() {\n    assert(\n      this.status === 'paused' || this.status === 'running',\n      new Error('Tried to cancel a not running Timer'),\n    );\n    this.onFinish(false);\n  }\n\n  /**\n   * Marks the timer as finished prematurely and triggers the callback.\n   *\n   * @throws {@link Error}. If it wasn't running or paused.\n   */\n  finish() {\n    assert(\n      this.status !== 'finished',\n      new Error('Tried to finish a finished Timer.'),\n    );\n    this.onFinish(true);\n  }\n\n  /**\n   * Pauses a currently running timer, allowing it to resume later.\n   *\n   * @throws {@link Error}. If it wasn't running.\n   */\n  pause() {\n    assert(\n      this.state.value === 'running',\n      new Error('Tried to pause a not running Timer'),\n    );\n\n    const { callback, start, timeout, remaining } = this.state;\n\n    timeout !== undefined && clearTimeout(timeout as any);\n    this.state = {\n      value: 'paused',\n      callback,\n      remaining: remaining - (Date.now() - start),\n    };\n  }\n\n  /**\n   * Starts the timer.\n   *\n   * @param callback - The function that will be called after the timer finishes.\n   * @throws {@link Error}. If it was already started.\n   */\n  start(callback: () => void) {\n    assert(\n      this.state.value === 'stopped',\n      new Error('Tried to start an already running Timer'),\n    );\n\n    const { remaining } = this.state;\n    this.state = { value: 'paused', remaining, callback };\n    this.resume();\n  }\n\n  /**\n   * Resumes a currently paused timer.\n   *\n   * @throws {@link Error}. If it wasn't paused.\n   */\n  resume() {\n    assert(\n      this.state.value === 'paused',\n      new Error('Tried to resume not paused Timer'),\n    );\n    const { remaining, callback } = this.state;\n    const start = Date.now();\n\n    let timeout: unknown;\n    // setTimeout returns immediately on +Infinity which we use\n    if (remaining !== Number.POSITIVE_INFINITY) {\n      timeout = setTimeout(() => this.onFinish(true), remaining);\n    }\n\n    this.state = { value: 'running', callback, remaining, start, timeout };\n  }\n\n  private onFinish(shouldCall: boolean) {\n    assert(this.state.value === 'running' || this.state.value === 'paused');\n\n    if (this.state.value === 'running' && this.state.timeout !== undefined) {\n      clearTimeout(this.state.timeout as any);\n    }\n\n    const { callback, remaining } = this.state;\n    this.state = {\n      value: 'finished',\n      remaining:\n        this.state.value === 'running'\n          ? remaining - (Date.now() - this.state.start)\n          : remaining,\n    };\n\n    if (shouldCall) {\n      callback();\n    }\n  }\n}\n"]}