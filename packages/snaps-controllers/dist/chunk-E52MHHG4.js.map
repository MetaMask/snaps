{"version":3,"sources":["../src/snaps/SnapController.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  AddApprovalRequest,\n  UpdateRequestState,\n} from '@metamask/approval-controller';\nimport type { RestrictedControllerMessenger } from '@metamask/base-controller';\nimport { BaseController } from '@metamask/base-controller';\nimport type {\n  Caveat,\n  GetEndowments,\n  GetPermissions,\n  GetSubjectMetadata,\n  AddSubjectMetadata,\n  GetSubjects,\n  GrantPermissions,\n  HasPermission,\n  HasPermissions,\n  PermissionConstraint,\n  PermissionsRequest,\n  RequestedPermissions,\n  RevokeAllPermissions,\n  RevokePermissionForAllSubjects,\n  RevokePermissions,\n  SubjectPermissions,\n  UpdateCaveat,\n  ValidPermission,\n} from '@metamask/permission-controller';\nimport { SubjectType } from '@metamask/permission-controller';\nimport { rpcErrors } from '@metamask/rpc-errors';\nimport type { BlockReason } from '@metamask/snaps-registry';\nimport {\n  WALLET_SNAP_PERMISSION_KEY,\n  getMaxRequestTimeCaveat,\n  handlerEndowments,\n  SnapEndowments,\n  getKeyringCaveatOrigins,\n  getRpcCaveatOrigins,\n  processSnapPermissions,\n  getEncryptionEntropy,\n} from '@metamask/snaps-rpc-methods';\nimport type {\n  RequestSnapsParams,\n  RequestSnapsResult,\n  SnapId,\n  ComponentOrElement,\n} from '@metamask/snaps-sdk';\nimport { AuxiliaryFileEncoding, getErrorMessage } from '@metamask/snaps-sdk';\nimport type {\n  FetchedSnapFiles,\n  InitialConnections,\n  PersistedSnap,\n  Snap,\n  SnapManifest,\n  SnapPermissions,\n  SnapRpcHookArgs,\n  StatusContext,\n  StatusEvents,\n  StatusStates,\n  TruncatedSnap,\n  TruncatedSnapFields,\n} from '@metamask/snaps-utils';\nimport {\n  assertIsSnapManifest,\n  assertIsValidSnapId,\n  DEFAULT_ENDOWMENTS,\n  DEFAULT_REQUESTED_SNAP_VERSION,\n  encodeAuxiliaryFile,\n  HandlerType,\n  isOriginAllowed,\n  logError,\n  normalizeRelative,\n  OnTransactionResponseStruct,\n  OnSignatureResponseStruct,\n  resolveVersionRange,\n  SnapCaveatType,\n  SnapStatus,\n  SnapStatusEvents,\n  unwrapError,\n  OnHomePageResponseStruct,\n  getValidatedLocalizationFiles,\n  VirtualFile,\n  NpmSnapFileNames,\n  OnNameLookupResponseStruct,\n  getLocalizedSnapManifest,\n  parseJson,\n} from '@metamask/snaps-utils';\nimport type { Json, NonEmptyArray, SemVerRange } from '@metamask/utils';\nimport {\n  assert,\n  assertIsJsonRpcRequest,\n  assertStruct,\n  Duration,\n  gtRange,\n  gtVersion,\n  hasProperty,\n  inMilliseconds,\n  isNonEmptyArray,\n  isValidJson,\n  isValidSemVerRange,\n  satisfiesVersionRange,\n  timeSince,\n} from '@metamask/utils';\nimport type { StateMachine } from '@xstate/fsm';\nimport { createMachine, interpret } from '@xstate/fsm';\nimport type { Patch } from 'immer';\nimport { nanoid } from 'nanoid';\n\nimport { forceStrict, validateMachine } from '../fsm';\nimport type { CreateInterface, GetInterface } from '../interface';\nimport { log } from '../logging';\nimport type {\n  ExecuteSnapAction,\n  ExecutionServiceEvents,\n  HandleRpcRequestAction,\n  SnapErrorJson,\n  TerminateAllSnapsAction,\n  TerminateSnapAction,\n} from '../services';\nimport type { EncryptionResult } from '../types';\nimport {\n  type ExportableKeyEncryptor,\n  type KeyDerivationOptions,\n} from '../types';\nimport {\n  calculateConnectionsChange,\n  fetchSnap,\n  hasTimedOut,\n  permissionsDiff,\n  setDiff,\n  withTimeout,\n} from '../utils';\nimport {\n  ALLOWED_PERMISSIONS,\n  LEGACY_ENCRYPTION_KEY_DERIVATION_OPTIONS,\n} from './constants';\nimport type { SnapLocation } from './location';\nimport { detectSnapLocation } from './location';\nimport type {\n  GetMetadata,\n  GetResult,\n  ResolveVersion,\n  SnapsRegistryInfo,\n  SnapsRegistryMetadata,\n  SnapsRegistryRequest,\n  Update,\n} from './registry';\nimport { SnapsRegistryStatus } from './registry';\nimport { RequestQueue } from './RequestQueue';\nimport { Timer } from './Timer';\n\nexport const controllerName = 'SnapController';\n\n// TODO: Figure out how to name these\nexport const SNAP_APPROVAL_INSTALL = 'wallet_installSnap';\nexport const SNAP_APPROVAL_UPDATE = 'wallet_updateSnap';\nexport const SNAP_APPROVAL_RESULT = 'wallet_installSnapResult';\n\nconst TRUNCATED_SNAP_PROPERTIES = new Set<TruncatedSnapFields>([\n  'initialPermissions',\n  'id',\n  'version',\n  'enabled',\n  'blocked',\n]);\n\nexport type PendingRequest = {\n  requestId: unknown;\n  timer: Timer;\n};\n\nexport interface PreinstalledSnapFile {\n  path: string;\n  value: string | Uint8Array;\n}\n\nexport interface PreinstalledSnap {\n  snapId: SnapId;\n  manifest: SnapManifest;\n  files: PreinstalledSnapFile[];\n  removable?: boolean;\n  hidden?: boolean;\n}\n\ntype SnapRpcHandler = (\n  options: SnapRpcHookArgs & { timeout: number },\n) => Promise<unknown>;\n\n/**\n * A wrapper type for any data stored during runtime of Snaps.\n * It is not persisted in state as it contains non-serializable data and is only relevant for the\n * current session.\n */\nexport interface SnapRuntimeData {\n  /**\n   * A promise that resolves when the Snap has finished installing\n   */\n  installPromise: null | Promise<PersistedSnap>;\n\n  /**\n   * A Unix timestamp for the last time the Snap received an RPC request\n   */\n  lastRequest: null | number;\n\n  /**\n   * The current number of active references where this Snap is being used\n   */\n  activeReferences: number;\n\n  /**\n   * The current pending inbound requests, meaning requests that are processed by snaps.\n   */\n  pendingInboundRequests: PendingRequest[];\n\n  /**\n   * The current pending outbound requests, meaning requests made from snaps towards the MetaMask\n   * extension.\n   */\n  pendingOutboundRequests: number;\n\n  /**\n   * RPC handler designated for the Snap\n   */\n  rpcHandler: null | SnapRpcHandler;\n\n  /**\n   * The finite state machine interpreter for possible states that the Snap can be in such as\n   * stopped, running, blocked\n   *\n   * @see {@link SnapController:constructor}\n   */\n  interpreter: StateMachine.Service<StatusContext, StatusEvents, StatusStates>;\n\n  /**\n   * Cached encryption key used for state encryption.\n   */\n  encryptionKey: string | null;\n\n  /**\n   * Cached encryption salt used for state encryption.\n   */\n  encryptionSalt: string | null;\n\n  /**\n   * A boolean flag to determine whether the Snap is currently being stopped.\n   */\n  stopping: boolean;\n}\n\nexport type SnapError = {\n  message: string;\n  code: number;\n  data?: Json;\n};\n\n// Types that probably should be defined elsewhere in prod\ntype CloseAllConnectionsFunction = (origin: string) => void;\ntype StoredSnaps = Record<SnapId, Snap>;\n\nexport type SnapControllerState = {\n  snaps: StoredSnaps;\n  snapStates: Record<SnapId, string | null>;\n  unencryptedSnapStates: Record<SnapId, string | null>;\n};\n\nexport type PersistedSnapControllerState = SnapControllerState & {\n  snaps: Record<SnapId, PersistedSnap>;\n  snapStates: Record<SnapId, string>;\n};\n\ntype RollbackSnapshot = {\n  statePatches: Patch[];\n  permissions: {\n    revoked?: SubjectPermissions<ValidPermission<string, Caveat<string, any>>>;\n    granted?: RequestedPermissions;\n    requestData?: Record<string, unknown>;\n  };\n  newVersion: string;\n};\n\ntype PendingApproval = {\n  id: string;\n  promise: Promise<unknown>;\n};\n\n// Controller Messenger Actions\n\n/**\n * Gets the specified Snap from state.\n */\nexport type GetSnap = {\n  type: `${typeof controllerName}:get`;\n  handler: SnapController['get'];\n};\n\n/**\n * Handles sending an inbound request to a snap and returns its result.\n */\nexport type HandleSnapRequest = {\n  type: `${typeof controllerName}:handleRequest`;\n  handler: SnapController['handleRequest'];\n};\n\n/**\n * Gets the specified Snap's persisted state.\n */\nexport type GetSnapState = {\n  type: `${typeof controllerName}:getSnapState`;\n  handler: SnapController['getSnapState'];\n};\n\n/**\n * Checks if the specified snap exists in state.\n */\nexport type HasSnap = {\n  type: `${typeof controllerName}:has`;\n  handler: SnapController['has'];\n};\n\n/**\n * Updates the specified Snap's persisted state.\n */\nexport type UpdateSnapState = {\n  type: `${typeof controllerName}:updateSnapState`;\n  handler: SnapController['updateSnapState'];\n};\n\n/**\n * Clears the specified Snap's persisted state.\n */\nexport type ClearSnapState = {\n  type: `${typeof controllerName}:clearSnapState`;\n  handler: SnapController['clearSnapState'];\n};\n\n/**\n * Checks all installed snaps against the blocklist.\n */\nexport type UpdateBlockedSnaps = {\n  type: `${typeof controllerName}:updateBlockedSnaps`;\n  handler: SnapController['updateBlockedSnaps'];\n};\n\nexport type EnableSnap = {\n  type: `${typeof controllerName}:enable`;\n  handler: SnapController['enableSnap'];\n};\n\nexport type DisableSnap = {\n  type: `${typeof controllerName}:disable`;\n  handler: SnapController['disableSnap'];\n};\n\nexport type RemoveSnap = {\n  type: `${typeof controllerName}:remove`;\n  handler: SnapController['removeSnap'];\n};\n\nexport type GetPermittedSnaps = {\n  type: `${typeof controllerName}:getPermitted`;\n  handler: SnapController['getPermittedSnaps'];\n};\n\nexport type GetAllSnaps = {\n  type: `${typeof controllerName}:getAll`;\n  handler: SnapController['getAllSnaps'];\n};\n\nexport type IncrementActiveReferences = {\n  type: `${typeof controllerName}:incrementActiveReferences`;\n  handler: SnapController['incrementActiveReferences'];\n};\n\nexport type DecrementActiveReferences = {\n  type: `${typeof controllerName}:decrementActiveReferences`;\n  handler: SnapController['decrementActiveReferences'];\n};\n\nexport type InstallSnaps = {\n  type: `${typeof controllerName}:install`;\n  handler: SnapController['installSnaps'];\n};\n\nexport type GetRegistryMetadata = {\n  type: `${typeof controllerName}:getRegistryMetadata`;\n  handler: SnapController['getRegistryMetadata'];\n};\n\nexport type DisconnectOrigin = {\n  type: `${typeof controllerName}:disconnectOrigin`;\n  handler: SnapController['removeSnapFromSubject'];\n};\n\nexport type RevokeDynamicPermissions = {\n  type: `${typeof controllerName}:revokeDynamicPermissions`;\n  handler: SnapController['revokeDynamicSnapPermissions'];\n};\n\nexport type GetSnapFile = {\n  type: `${typeof controllerName}:getFile`;\n  handler: SnapController['getSnapFile'];\n};\n\nexport type SnapControllerActions =\n  | ClearSnapState\n  | GetSnap\n  | GetSnapState\n  | HandleSnapRequest\n  | HasSnap\n  | UpdateBlockedSnaps\n  | UpdateSnapState\n  | EnableSnap\n  | DisableSnap\n  | RemoveSnap\n  | GetPermittedSnaps\n  | InstallSnaps\n  | GetAllSnaps\n  | IncrementActiveReferences\n  | DecrementActiveReferences\n  | GetRegistryMetadata\n  | DisconnectOrigin\n  | RevokeDynamicPermissions\n  | GetSnapFile;\n\n// Controller Messenger Events\n\nexport type SnapStateChange = {\n  type: `${typeof controllerName}:stateChange`;\n  payload: [SnapControllerState, Patch[]];\n};\n\n/**\n * Emitted when an installed snap has been blocked.\n */\nexport type SnapBlocked = {\n  type: `${typeof controllerName}:snapBlocked`;\n  payload: [snapId: string, blockedSnapInfo?: BlockReason];\n};\n\n/**\n * Emitted when a snap installation or update is started.\n */\nexport type SnapInstallStarted = {\n  type: `${typeof controllerName}:snapInstallStarted`;\n  payload: [snapId: SnapId, origin: string, isUpdate: boolean];\n};\n\n/**\n * Emitted when a snap installation or update failed.\n */\nexport type SnapInstallFailed = {\n  type: `${typeof controllerName}:snapInstallFailed`;\n  payload: [snapId: SnapId, origin: string, isUpdate: boolean, error: string];\n};\n\n/**\n * Emitted when a snap has been started after being added and authorized during\n * installation.\n */\nexport type SnapInstalled = {\n  type: `${typeof controllerName}:snapInstalled`;\n  payload: [snap: TruncatedSnap, origin: string];\n};\n\n/**\n * Emitted when a snap that has previously been fully installed, is uninstalled.\n */\nexport type SnapUninstalled = {\n  type: `${typeof controllerName}:snapUninstalled`;\n  payload: [snap: TruncatedSnap];\n};\n\n/**\n * Emitted when an installed snap has been unblocked.\n */\nexport type SnapUnblocked = {\n  type: `${typeof controllerName}:snapUnblocked`;\n  payload: [snapId: string];\n};\n\n/**\n * Emitted when a snap is updated.\n */\nexport type SnapUpdated = {\n  type: `${typeof controllerName}:snapUpdated`;\n  payload: [snap: TruncatedSnap, oldVersion: string, origin: string];\n};\n\n/**\n * Emitted when a snap is rolled back.\n */\nexport type SnapRolledback = {\n  type: `${typeof controllerName}:snapRolledback`;\n  payload: [snap: TruncatedSnap, failedVersion: string];\n};\n\n/**\n * Emitted when a Snap is terminated. This is different from the snap being\n * stopped as it can also be triggered when a snap fails initialization.\n */\nexport type SnapTerminated = {\n  type: `${typeof controllerName}:snapTerminated`;\n  payload: [snap: TruncatedSnap];\n};\n\n/**\n * Emitted when a Snap is enabled by a user.\n * This is not emitted by default when installing a snap.\n */\nexport type SnapEnabled = {\n  type: `${typeof controllerName}:snapEnabled`;\n  payload: [snap: TruncatedSnap];\n};\n\n/**\n * Emitted when a Snap is disabled by a user.\n */\nexport type SnapDisabled = {\n  type: `${typeof controllerName}:snapDisabled`;\n  payload: [snap: TruncatedSnap];\n};\n\nexport type SnapControllerEvents =\n  | SnapBlocked\n  | SnapInstalled\n  | SnapUninstalled\n  | SnapInstallStarted\n  | SnapInstallFailed\n  | SnapStateChange\n  | SnapUnblocked\n  | SnapUpdated\n  | SnapRolledback\n  | SnapTerminated\n  | SnapEnabled\n  | SnapDisabled;\n\nexport type AllowedActions =\n  | GetEndowments\n  | GetPermissions\n  | GetSubjects\n  | GetSubjectMetadata\n  | AddSubjectMetadata\n  | HasPermission\n  | HasPermissions\n  | RevokePermissions\n  | RevokeAllPermissions\n  | RevokePermissionForAllSubjects\n  | GrantPermissions\n  | AddApprovalRequest\n  | HandleRpcRequestAction\n  | ExecuteSnapAction\n  | TerminateAllSnapsAction\n  | TerminateSnapAction\n  | UpdateCaveat\n  | UpdateRequestState\n  | GetResult\n  | GetMetadata\n  | Update\n  | ResolveVersion\n  | CreateInterface\n  | GetInterface;\n\nexport type AllowedEvents =\n  | ExecutionServiceEvents\n  | SnapInstalled\n  | SnapUpdated;\n\ntype SnapControllerMessenger = RestrictedControllerMessenger<\n  typeof controllerName,\n  SnapControllerActions | AllowedActions,\n  SnapControllerEvents | AllowedEvents,\n  AllowedActions['type'],\n  AllowedEvents['type']\n>;\n\ntype FeatureFlags = {\n  requireAllowlist?: boolean;\n  allowLocalSnaps?: boolean;\n  disableSnapInstallation?: boolean;\n};\n\ntype DynamicFeatureFlags = {\n  disableSnaps?: boolean;\n};\n\ntype SnapControllerArgs = {\n  /**\n   * A teardown function that allows the host to clean up its instrumentation\n   * for a running snap.\n   */\n  closeAllConnections?: CloseAllConnectionsFunction;\n\n  /**\n   * A list of permissions that are allowed to be dynamic, meaning they can be revoked from the snap whenever.\n   */\n  dynamicPermissions?: string[];\n\n  /**\n   * The names of endowment permissions whose values are the names of JavaScript\n   * APIs that will be added to the snap execution environment at runtime.\n   */\n  environmentEndowmentPermissions?: string[];\n\n  /**\n   * Excluded permissions with its associated error message used to forbid certain permssions.\n   */\n  excludedPermissions?: Record<string, string>;\n\n  /**\n   * The function that will be used by the controller fo make network requests.\n   * Should be compatible with {@link fetch}.\n   */\n  fetchFunction?: typeof fetch;\n\n  /**\n   * Flags that enable or disable features in the controller.\n   * See {@link FeatureFlags}.\n   */\n  featureFlags: FeatureFlags;\n\n  /**\n   * How frequently to check whether a snap is idle.\n   */\n  idleTimeCheckInterval?: number;\n\n  /**\n   * The maximum amount of time that a snap may be idle.\n   */\n  maxIdleTime?: number;\n\n  /**\n   * The controller messenger.\n   */\n  messenger: SnapControllerMessenger;\n\n  /**\n   * The maximum amount of time a snap may take to process an RPC request,\n   * unless it is permitted to take longer.\n   */\n  maxRequestTime?: number;\n\n  /**\n   * The npm registry URL that will be used to fetch published snaps.\n   */\n  npmRegistryUrl?: string;\n\n  /**\n   * Persisted state that will be used for rehydration.\n   */\n  state?: PersistedSnapControllerState;\n\n  /**\n   * A function that takes Snap Id and converts it into a class that fetches files.\n   *\n   * Used for test overrides.\n   */\n  detectSnapLocation?: typeof detectSnapLocation;\n\n  /**\n   * A list of snaps to be preinstalled into the SnapController state on initialization.\n   */\n  preinstalledSnaps?: PreinstalledSnap[] | null;\n\n  /**\n   * A utility object containing functions required for state encryption.\n   */\n  encryptor: ExportableKeyEncryptor;\n\n  /**\n   * A hook to access the mnemonic of the user's primary keyring.\n   *\n   * @returns The mnemonic as bytes.\n   */\n  getMnemonic: () => Promise<Uint8Array>;\n\n  /**\n   * A hook to get dynamic feature flags at runtime.\n   *\n   * @returns The feature flags.\n   */\n  getFeatureFlags: () => DynamicFeatureFlags;\n};\ntype AddSnapArgs = {\n  id: SnapId;\n  origin: string;\n  location: SnapLocation;\n  versionRange: SemVerRange;\n};\n\n// When we set a snap, we need all required properties to be present and\n// validated.\ntype SetSnapArgs = Omit<AddSnapArgs, 'location' | 'versionRange'> & {\n  files: FetchedSnapFiles;\n  isUpdate?: boolean;\n  removable?: boolean;\n  preinstalled?: boolean;\n  hidden?: boolean;\n};\n\nconst defaultState: SnapControllerState = {\n  snaps: {},\n  snapStates: {},\n  unencryptedSnapStates: {},\n};\n\n/**\n * Truncates the properties of a snap to only ones that are easily serializable.\n *\n * @param snap - The snap to truncate.\n * @returns Object with serializable snap properties.\n */\nfunction truncateSnap(snap: Snap): TruncatedSnap {\n  const truncatedSnap = Object.keys(snap).reduce<Partial<TruncatedSnap>>(\n    (serialized, key) => {\n      if (TRUNCATED_SNAP_PROPERTIES.has(key as any)) {\n        serialized[key as keyof TruncatedSnap] = snap[\n          key as keyof TruncatedSnap\n        ] as any;\n      }\n\n      return serialized;\n    },\n    {},\n  );\n\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n  return truncatedSnap as TruncatedSnap;\n}\n\nconst name = 'SnapController';\n\n/*\n * A snap is initialized in three phases:\n * - Add: Loads the snap from a remote source and parses it.\n * - Authorize: Requests the snap's required permissions from the user.\n * - Start: Initializes the snap in its SES realm with the authorized permissions.\n */\n\nexport class SnapController extends BaseController<\n  string,\n  SnapControllerState,\n  SnapControllerMessenger\n> {\n  #closeAllConnections?: CloseAllConnectionsFunction;\n\n  #dynamicPermissions: string[];\n\n  #environmentEndowmentPermissions: string[];\n\n  #excludedPermissions: Record<string, string>;\n\n  #featureFlags: FeatureFlags;\n\n  #fetchFunction: typeof fetch;\n\n  #idleTimeCheckInterval: number;\n\n  #maxIdleTime: number;\n\n  // This property cannot be hash private yet because of tests.\n  private readonly maxRequestTime: number;\n\n  #encryptor: ExportableKeyEncryptor;\n\n  #getMnemonic: () => Promise<Uint8Array>;\n\n  #getFeatureFlags: () => DynamicFeatureFlags;\n\n  #detectSnapLocation: typeof detectSnapLocation;\n\n  #snapsRuntimeData: Map<SnapId, SnapRuntimeData>;\n\n  #rollbackSnapshots: Map<string, RollbackSnapshot>;\n\n  #timeoutForLastRequestStatus?: number;\n\n  #statusMachine!: StateMachine.Machine<\n    StatusContext,\n    StatusEvents,\n    StatusStates\n  >;\n\n  #preinstalledSnaps: PreinstalledSnap[] | null;\n\n  constructor({\n    closeAllConnections,\n    messenger,\n    state,\n    dynamicPermissions = ['eth_accounts'],\n    environmentEndowmentPermissions = [],\n    excludedPermissions = {},\n    idleTimeCheckInterval = inMilliseconds(5, Duration.Second),\n    maxIdleTime = inMilliseconds(30, Duration.Second),\n    maxRequestTime = inMilliseconds(60, Duration.Second),\n    fetchFunction = globalThis.fetch.bind(globalThis),\n    featureFlags = {},\n    detectSnapLocation: detectSnapLocationFunction = detectSnapLocation,\n    preinstalledSnaps = null,\n    encryptor,\n    getMnemonic,\n    getFeatureFlags = () => ({}),\n  }: SnapControllerArgs) {\n    super({\n      messenger,\n      metadata: {\n        snapStates: {\n          persist: true,\n          anonymous: false,\n        },\n        unencryptedSnapStates: {\n          persist: true,\n          anonymous: false,\n        },\n        snaps: {\n          persist: (snaps) => {\n            return (\n              Object.values(snaps)\n                // We should not persist snaps that are in the installing state,\n                // since they haven't completed installation and would be unusable\n                .filter((snap) => snap.status !== SnapStatus.Installing)\n                .map((snap) => {\n                  return {\n                    ...snap,\n                    // At the time state is rehydrated, no snap will be running.\n                    status: SnapStatus.Stopped,\n                  };\n                })\n                .reduce((memo: Record<SnapId, Snap>, snap) => {\n                  memo[snap.id] = snap;\n                  return memo;\n                }, {})\n            );\n          },\n          anonymous: false,\n        },\n      },\n      name,\n      state: {\n        ...defaultState,\n        ...state,\n      },\n    });\n\n    this.#closeAllConnections = closeAllConnections;\n    this.#dynamicPermissions = dynamicPermissions;\n    this.#environmentEndowmentPermissions = environmentEndowmentPermissions;\n    this.#excludedPermissions = excludedPermissions;\n    this.#featureFlags = featureFlags;\n    this.#fetchFunction = fetchFunction;\n    this.#idleTimeCheckInterval = idleTimeCheckInterval;\n    this.#maxIdleTime = maxIdleTime;\n    this.maxRequestTime = maxRequestTime;\n    this.#detectSnapLocation = detectSnapLocationFunction;\n    this.#encryptor = encryptor;\n    this.#getMnemonic = getMnemonic;\n    this.#getFeatureFlags = getFeatureFlags;\n    this.#preinstalledSnaps = preinstalledSnaps;\n    this._onUnhandledSnapError = this._onUnhandledSnapError.bind(this);\n    this._onOutboundRequest = this._onOutboundRequest.bind(this);\n    this._onOutboundResponse = this._onOutboundResponse.bind(this);\n    this.#rollbackSnapshots = new Map();\n    this.#snapsRuntimeData = new Map();\n    this.#pollForLastRequestStatus();\n\n    /* eslint-disable @typescript-eslint/unbound-method */\n    this.messagingSystem.subscribe(\n      'ExecutionService:unhandledError',\n      this._onUnhandledSnapError,\n    );\n\n    this.messagingSystem.subscribe(\n      'ExecutionService:outboundRequest',\n      this._onOutboundRequest,\n    );\n\n    this.messagingSystem.subscribe(\n      'ExecutionService:outboundResponse',\n      this._onOutboundResponse,\n    );\n    /* eslint-enable @typescript-eslint/unbound-method */\n\n    this.messagingSystem.subscribe(\n      'SnapController:snapInstalled',\n      ({ id }, origin) => {\n        this.#callLifecycleHook(origin, id, HandlerType.OnInstall).catch(\n          (error) => {\n            logError(\n              `Error when calling \\`onInstall\\` lifecycle hook for snap \"${id}\": ${getErrorMessage(\n                error,\n              )}`,\n            );\n          },\n        );\n      },\n    );\n\n    this.messagingSystem.subscribe(\n      'SnapController:snapUpdated',\n      ({ id }, _oldVersion, origin) => {\n        this.#callLifecycleHook(origin, id, HandlerType.OnUpdate).catch(\n          (error) => {\n            logError(\n              `Error when calling \\`onUpdate\\` lifecycle hook for snap \"${id}\": ${getErrorMessage(\n                error,\n              )}`,\n            );\n          },\n        );\n      },\n    );\n\n    this.#initializeStateMachine();\n    this.#registerMessageHandlers();\n\n    if (this.#preinstalledSnaps) {\n      this.#handlePreinstalledSnaps(this.#preinstalledSnaps);\n    }\n\n    Object.values(this.state?.snaps ?? {}).forEach((snap) =>\n      this.#setupRuntime(snap.id),\n    );\n  }\n\n  /**\n   * We track status of a Snap using a finite-state-machine.\n   * It keeps track of whether the snap is started / stopped / etc.\n   *\n   * @see {@link SnapController.transition} for interacting with the machine.\n   */\n  // We initialize the machine in the instance because the status is currently tightly coupled\n  // with the SnapController - the guard checks for enabled status inside the SnapController state.\n  // In the future, side-effects could be added to the machine during transitions.\n  #initializeStateMachine() {\n    const disableGuard = ({ snapId }: StatusContext) => {\n      return this.getExpect(snapId).enabled;\n    };\n\n    const statusConfig: StateMachine.Config<\n      StatusContext,\n      StatusEvents,\n      StatusStates\n    > = {\n      initial: SnapStatus.Installing,\n      states: {\n        [SnapStatus.Installing]: {\n          on: {\n            [SnapStatusEvents.Start]: {\n              target: SnapStatus.Running,\n              cond: disableGuard,\n            },\n          },\n        },\n        [SnapStatus.Updating]: {\n          on: {\n            [SnapStatusEvents.Start]: {\n              target: SnapStatus.Running,\n              cond: disableGuard,\n            },\n            [SnapStatusEvents.Stop]: SnapStatus.Stopped,\n          },\n        },\n        [SnapStatus.Running]: {\n          on: {\n            [SnapStatusEvents.Stop]: SnapStatus.Stopped,\n            [SnapStatusEvents.Crash]: SnapStatus.Crashed,\n          },\n        },\n        [SnapStatus.Stopped]: {\n          on: {\n            [SnapStatusEvents.Start]: {\n              target: SnapStatus.Running,\n              cond: disableGuard,\n            },\n            [SnapStatusEvents.Update]: SnapStatus.Updating,\n          },\n        },\n        [SnapStatus.Crashed]: {\n          on: {\n            [SnapStatusEvents.Start]: {\n              target: SnapStatus.Running,\n              cond: disableGuard,\n            },\n            [SnapStatusEvents.Update]: SnapStatus.Updating,\n          },\n        },\n      },\n    };\n    this.#statusMachine = createMachine(statusConfig);\n    validateMachine(this.#statusMachine);\n  }\n\n  /**\n   * Constructor helper for registering the controller's messaging system\n   * actions.\n   */\n  #registerMessageHandlers(): void {\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:clearSnapState`,\n      (...args) => this.clearSnapState(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:get`,\n      (...args) => this.get(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:getSnapState`,\n      async (...args) => this.getSnapState(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:handleRequest`,\n      async (...args) => this.handleRequest(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:has`,\n      (...args) => this.has(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:updateBlockedSnaps`,\n      async () => this.updateBlockedSnaps(),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:updateSnapState`,\n      async (...args) => this.updateSnapState(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:enable`,\n      (...args) => this.enableSnap(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:disable`,\n      async (...args) => this.disableSnap(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:remove`,\n      async (...args) => this.removeSnap(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:getPermitted`,\n      (...args) => this.getPermittedSnaps(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:install`,\n      async (...args) => this.installSnaps(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:getAll`,\n      (...args) => this.getAllSnaps(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:incrementActiveReferences`,\n      (...args) => this.incrementActiveReferences(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:decrementActiveReferences`,\n      (...args) => this.decrementActiveReferences(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:getRegistryMetadata`,\n      async (...args) => this.getRegistryMetadata(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:disconnectOrigin`,\n      (...args) => this.removeSnapFromSubject(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:revokeDynamicPermissions`,\n      (...args) => this.revokeDynamicSnapPermissions(...args),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${controllerName}:getFile`,\n      async (...args) => this.getSnapFile(...args),\n    );\n  }\n\n  #handlePreinstalledSnaps(preinstalledSnaps: PreinstalledSnap[]) {\n    for (const {\n      snapId,\n      manifest,\n      files,\n      removable,\n      hidden,\n    } of preinstalledSnaps) {\n      const existingSnap = this.get(snapId);\n      const isAlreadyInstalled = existingSnap !== undefined;\n      const isUpdate =\n        isAlreadyInstalled && gtVersion(manifest.version, existingSnap.version);\n\n      // Disallow downgrades and overwriting non preinstalled snaps\n      if (\n        isAlreadyInstalled &&\n        (!isUpdate || existingSnap.preinstalled !== true)\n      ) {\n        continue;\n      }\n\n      const manifestFile = new VirtualFile<SnapManifest>({\n        path: NpmSnapFileNames.Manifest,\n        value: JSON.stringify(manifest),\n        result: manifest,\n      });\n\n      const virtualFiles = files.map(\n        ({ path, value }) => new VirtualFile({ value, path }),\n      );\n      const { filePath, iconPath } = manifest.source.location.npm;\n      const sourceCode = virtualFiles.find((file) => file.path === filePath);\n      const svgIcon = iconPath\n        ? virtualFiles.find((file) => file.path === iconPath)\n        : undefined;\n\n      assert(sourceCode, 'Source code not provided for preinstalled snap.');\n\n      assert(\n        !iconPath || (iconPath && svgIcon),\n        'Icon not provided for preinstalled snap.',\n      );\n\n      assert(\n        manifest.source.files === undefined,\n        'Auxiliary files are not currently supported for preinstalled snaps.',\n      );\n\n      const localizationFiles =\n        manifest.source.locales?.map((path) =>\n          virtualFiles.find((file) => file.path === path),\n        ) ?? [];\n\n      const validatedLocalizationFiles = getValidatedLocalizationFiles(\n        localizationFiles.filter(Boolean) as VirtualFile<unknown>[],\n      );\n\n      assert(\n        localizationFiles.length === validatedLocalizationFiles.length,\n        'Missing localization files for preinstalled snap.',\n      );\n\n      const filesObject: FetchedSnapFiles = {\n        manifest: manifestFile,\n        sourceCode,\n        svgIcon,\n        auxiliaryFiles: [],\n        localizationFiles: validatedLocalizationFiles,\n      };\n\n      // Add snap to the SnapController state\n      this.#set({\n        id: snapId,\n        origin: 'metamask',\n        files: filesObject,\n        removable,\n        hidden,\n        preinstalled: true,\n      });\n\n      // Setup permissions\n      const processedPermissions = processSnapPermissions(\n        manifest.initialPermissions,\n      );\n\n      this.#validateSnapPermissions(processedPermissions);\n\n      const { newPermissions, unusedPermissions } =\n        this.#calculatePermissionsChange(snapId, processedPermissions);\n\n      this.#updatePermissions({ snapId, newPermissions, unusedPermissions });\n\n      // Set status\n      this.update((state) => {\n        state.snaps[snapId].status = SnapStatus.Stopped;\n      });\n    }\n  }\n\n  #pollForLastRequestStatus() {\n    this.#timeoutForLastRequestStatus = setTimeout(() => {\n      this.#stopSnapsLastRequestPastMax().catch((error) => {\n        // TODO: Decide how to handle errors.\n        logError(error);\n      });\n\n      this.#pollForLastRequestStatus();\n    }, this.#idleTimeCheckInterval) as unknown as number;\n  }\n\n  /**\n   * Checks all installed snaps against the block list and\n   * blocks/unblocks snaps as appropriate. See {@link SnapController.blockSnap}\n   * for more information.\n   */\n  async updateBlockedSnaps(): Promise<void> {\n    this.#assertCanUsePlatform();\n    await this.messagingSystem.call('SnapsRegistry:update');\n\n    const blockedSnaps = await this.messagingSystem.call(\n      'SnapsRegistry:get',\n      Object.values(this.state.snaps).reduce<SnapsRegistryRequest>(\n        (blockListArg, snap) => {\n          blockListArg[snap.id] = {\n            version: snap.version,\n            checksum: snap.manifest.source.shasum,\n          };\n          return blockListArg;\n        },\n        {},\n      ),\n    );\n\n    await Promise.all(\n      Object.entries(blockedSnaps).map(async ([snapId, { status, reason }]) => {\n        if (status === SnapsRegistryStatus.Blocked) {\n          return this.#blockSnap(snapId as SnapId, reason);\n        }\n\n        return this.#unblockSnap(snapId as SnapId);\n      }),\n    );\n  }\n\n  /**\n   * Blocks an installed snap and prevents it from being started again. Emits\n   * {@link SnapBlocked}. Does nothing if the snap is not installed.\n   *\n   * @param snapId - The snap to block.\n   * @param blockedSnapInfo - Information detailing why the snap is blocked.\n   */\n  async #blockSnap(\n    snapId: SnapId,\n    blockedSnapInfo?: BlockReason,\n  ): Promise<void> {\n    if (!this.has(snapId)) {\n      return;\n    }\n\n    try {\n      this.update((state: any) => {\n        state.snaps[snapId].blocked = true;\n        state.snaps[snapId].blockInformation = blockedSnapInfo;\n      });\n\n      await this.disableSnap(snapId);\n    } catch (error) {\n      logError(\n        `Encountered error when stopping blocked snap \"${snapId}\".`,\n        error,\n      );\n    }\n\n    this.messagingSystem.publish(\n      `${controllerName}:snapBlocked`,\n      snapId,\n      blockedSnapInfo,\n    );\n  }\n\n  /**\n   * Unblocks a snap so that it can be enabled and started again. Emits\n   * {@link SnapUnblocked}. Does nothing if the snap is not installed or already\n   * unblocked.\n   *\n   * @param snapId - The id of the snap to unblock.\n   */\n  #unblockSnap(snapId: SnapId) {\n    if (!this.has(snapId) || !this.state.snaps[snapId].blocked) {\n      return;\n    }\n\n    this.update((state: any) => {\n      state.snaps[snapId].blocked = false;\n      delete state.snaps[snapId].blockInformation;\n    });\n\n    this.messagingSystem.publish(`${controllerName}:snapUnblocked`, snapId);\n  }\n\n  async #assertIsInstallAllowed(\n    snapId: SnapId,\n    snapInfo: SnapsRegistryInfo & { permissions: SnapPermissions },\n  ) {\n    const results = await this.messagingSystem.call('SnapsRegistry:get', {\n      [snapId]: snapInfo,\n    });\n    const result = results[snapId];\n    if (result.status === SnapsRegistryStatus.Blocked) {\n      throw new Error(\n        `Cannot install version \"${\n          snapInfo.version\n        }\" of snap \"${snapId}\": The version is blocked. ${\n          result.reason?.explanation ?? ''\n        }`,\n      );\n    }\n\n    const isAllowlistingRequired = Object.keys(snapInfo.permissions).some(\n      (permission) => !ALLOWED_PERMISSIONS.includes(permission),\n    );\n\n    if (\n      this.#featureFlags.requireAllowlist &&\n      isAllowlistingRequired &&\n      result.status !== SnapsRegistryStatus.Verified\n    ) {\n      throw new Error(\n        `Cannot install version \"${snapInfo.version}\" of snap \"${snapId}\": ${\n          result.status === SnapsRegistryStatus.Unavailable\n            ? 'The registry is temporarily unavailable.'\n            : 'The snap is not on the allowlist.'\n        }`,\n      );\n    }\n  }\n\n  /**\n   * Asserts whether new Snaps are allowed to be installed.\n   */\n  #assertCanInstallSnaps() {\n    assert(\n      this.#featureFlags.disableSnapInstallation !== true,\n      'Installing Snaps is currently disabled in this version of MetaMask.',\n    );\n  }\n\n  /**\n   * Asserts whether the Snaps platform is allowed to run.\n   */\n  #assertCanUsePlatform() {\n    const flags = this.#getFeatureFlags();\n    assert(\n      flags.disableSnaps !== true,\n      'The Snaps platform requires basic functionality to be used. Enable basic functionality in the settings to use the Snaps platform.',\n    );\n  }\n\n  async #stopSnapsLastRequestPastMax() {\n    const entries = [...this.#snapsRuntimeData.entries()];\n    return Promise.all(\n      entries\n        .filter(\n          ([_snapId, runtime]) =>\n            runtime.activeReferences === 0 &&\n            runtime.pendingInboundRequests.length === 0 &&\n            runtime.lastRequest &&\n            this.#maxIdleTime &&\n            timeSince(runtime.lastRequest) > this.#maxIdleTime,\n        )\n        .map(async ([snapId]) => this.stopSnap(snapId, SnapStatusEvents.Stop)),\n    );\n  }\n\n  _onUnhandledSnapError(snapId: string, _error: SnapErrorJson) {\n    this.stopSnap(snapId as SnapId, SnapStatusEvents.Crash).catch(\n      (stopSnapError) => {\n        // TODO: Decide how to handle errors.\n        logError(stopSnapError);\n      },\n    );\n  }\n\n  _onOutboundRequest(snapId: string) {\n    const runtime = this.#getRuntimeExpect(snapId as SnapId);\n    // Ideally we would only pause the pending request that is making the outbound request\n    // but right now we don't have a way to know which request initiated the outbound request\n    runtime.pendingInboundRequests\n      .filter((pendingRequest) => pendingRequest.timer.status === 'running')\n      .forEach((pendingRequest) => pendingRequest.timer.pause());\n    runtime.pendingOutboundRequests += 1;\n  }\n\n  _onOutboundResponse(snapId: string) {\n    const runtime = this.#getRuntimeExpect(snapId as SnapId);\n    runtime.pendingOutboundRequests -= 1;\n    if (runtime.pendingOutboundRequests === 0) {\n      runtime.pendingInboundRequests\n        .filter((pendingRequest) => pendingRequest.timer.status === 'paused')\n        .forEach((pendingRequest) => pendingRequest.timer.resume());\n    }\n  }\n\n  /**\n   * Transitions between states using `snapStatusStateMachineConfig` as the template to figure out\n   * the next state. This transition function uses a very minimal subset of XState conventions:\n   * - supports initial state\n   * - .on supports raw event target string\n   * - .on supports {target, cond} object\n   * - the arguments for `cond` is the `SerializedSnap` instead of Xstate convention of `(event,\n   * context) => boolean`\n   *\n   * @param snapId - The id of the snap to transition.\n   * @param event - The event enum to use to transition.\n   */\n  #transition(snapId: SnapId, event: StatusEvents | StatusEvents['type']) {\n    const { interpreter } = this.#getRuntimeExpect(snapId);\n    interpreter.send(event);\n    this.update((state: any) => {\n      state.snaps[snapId].status = interpreter.state.value;\n    });\n  }\n\n  /**\n   * Starts the given snap. Throws an error if no such snap exists\n   * or if it is already running.\n   *\n   * @param snapId - The id of the Snap to start.\n   */\n  async startSnap(snapId: SnapId): Promise<void> {\n    this.#assertCanUsePlatform();\n    const snap = this.state.snaps[snapId];\n\n    if (snap.enabled === false) {\n      throw new Error(`Snap \"${snapId}\" is disabled.`);\n    }\n\n    await this.#startSnap({\n      snapId,\n      sourceCode: snap.sourceCode,\n    });\n  }\n\n  /**\n   * Enables the given snap. A snap can only be started if it is enabled. A snap\n   * can only be enabled if it isn't blocked.\n   *\n   * @param snapId - The id of the Snap to enable.\n   */\n  enableSnap(snapId: SnapId): void {\n    this.getExpect(snapId);\n\n    if (this.state.snaps[snapId].blocked) {\n      throw new Error(`Snap \"${snapId}\" is blocked and cannot be enabled.`);\n    }\n\n    this.update((state: any) => {\n      state.snaps[snapId].enabled = true;\n    });\n\n    this.messagingSystem.publish(\n      'SnapController:snapEnabled',\n      this.getTruncatedExpect(snapId),\n    );\n  }\n\n  /**\n   * Disables the given snap. A snap can only be started if it is enabled.\n   *\n   * @param snapId - The id of the Snap to disable.\n   * @returns A promise that resolves once the snap has been disabled.\n   */\n  async disableSnap(snapId: SnapId): Promise<void> {\n    if (!this.has(snapId)) {\n      throw new Error(`Snap \"${snapId}\" not found.`);\n    }\n\n    this.update((state: any) => {\n      state.snaps[snapId].enabled = false;\n    });\n\n    if (this.isRunning(snapId)) {\n      await this.stopSnap(snapId, SnapStatusEvents.Stop);\n    }\n\n    this.messagingSystem.publish(\n      'SnapController:snapDisabled',\n      this.getTruncatedExpect(snapId),\n    );\n  }\n\n  /**\n   * Stops the given snap, removes all hooks, closes all connections, and\n   * terminates its worker.\n   *\n   * @param snapId - The id of the Snap to stop.\n   * @param statusEvent - The Snap status event that caused the snap to be\n   * stopped.\n   */\n  public async stopSnap(\n    snapId: SnapId,\n    statusEvent:\n      | SnapStatusEvents.Stop\n      | SnapStatusEvents.Crash = SnapStatusEvents.Stop,\n  ): Promise<void> {\n    const runtime = this.#getRuntime(snapId);\n    if (!runtime) {\n      throw new Error(`The snap \"${snapId}\" is not running.`);\n    }\n\n    // No-op if the Snap is already stopping.\n    if (runtime.stopping) {\n      return;\n    }\n\n    // Flag that the Snap is actively stopping, this prevents other calls to stopSnap\n    // while we are handling termination of the Snap\n    runtime.stopping = true;\n\n    try {\n      if (this.isRunning(snapId)) {\n        this.#closeAllConnections?.(snapId);\n        await this.#terminateSnap(snapId);\n      }\n    } finally {\n      // Reset request tracking\n      runtime.lastRequest = null;\n      runtime.pendingInboundRequests = [];\n      runtime.pendingOutboundRequests = 0;\n      runtime.stopping = false;\n      if (this.isRunning(snapId)) {\n        this.#transition(snapId, statusEvent);\n      }\n    }\n  }\n\n  /**\n   * Terminates the specified snap and emits the `snapTerminated` event.\n   *\n   * @param snapId - The snap to terminate.\n   */\n  async #terminateSnap(snapId: SnapId) {\n    await this.messagingSystem.call('ExecutionService:terminateSnap', snapId);\n\n    // Hack to give up execution for a bit to let gracefully terminating Snaps return.\n    await new Promise((resolve) => setTimeout(resolve, 1));\n\n    const runtime = this.#getRuntimeExpect(snapId);\n    // Unresponsive requests may still be timed, time them out.\n    runtime.pendingInboundRequests\n      .filter((pendingRequest) => pendingRequest.timer.status !== 'finished')\n      .forEach((pendingRequest) => pendingRequest.timer.finish());\n\n    // Hack to give up execution for a bit to let timed out requests return.\n    await new Promise((resolve) => setTimeout(resolve, 1));\n\n    this.messagingSystem.publish(\n      'SnapController:snapTerminated',\n      this.getTruncatedExpect(snapId),\n    );\n  }\n\n  /**\n   * Returns whether the given snap is running.\n   * Throws an error if the snap doesn't exist.\n   *\n   * @param snapId - The id of the Snap to check.\n   * @returns `true` if the snap is running, otherwise `false`.\n   */\n  isRunning(snapId: SnapId): boolean {\n    return this.getExpect(snapId).status === 'running';\n  }\n\n  /**\n   * Returns whether the given snap has been added to state.\n   *\n   * @param snapId - The id of the Snap to check for.\n   * @returns `true` if the snap exists in the controller state, otherwise `false`.\n   */\n  has(snapId: SnapId): boolean {\n    return Boolean(this.get(snapId));\n  }\n\n  /**\n   * Gets the snap with the given id if it exists, including all data.\n   * This should not be used if the snap is to be serializable, as e.g.\n   * the snap sourceCode may be quite large.\n   *\n   * @param snapId - The id of the Snap to get.\n   * @returns The entire snap object from the controller state.\n   */\n  get(snapId: string): Snap | undefined {\n    return this.state.snaps[snapId as SnapId];\n  }\n\n  /**\n   * Gets the snap with the given id, throws if doesn't.\n   * This should not be used if the snap is to be serializable, as e.g.\n   * the snap sourceCode may be quite large.\n   *\n   * @see {@link SnapController.get}\n   * @throws {@link Error}. If the snap doesn't exist\n   * @param snapId - The id of the snap to get.\n   * @returns The entire snap object.\n   */\n  getExpect(snapId: SnapId): Snap {\n    const snap = this.get(snapId);\n    assert(snap !== undefined, new Error(`Snap \"${snapId}\" not found.`));\n    return snap;\n  }\n\n  /**\n   * Gets the snap with the given id if it exists, excluding any\n   * non-serializable or expensive-to-serialize data.\n   *\n   * @param snapId - The id of the Snap to get.\n   * @returns A truncated version of the snap state, that is less expensive to serialize.\n   */\n  // TODO(ritave): this.get returns undefined, this.getTruncated returns null\n  getTruncated(snapId: SnapId): TruncatedSnap | null {\n    const snap = this.get(snapId);\n\n    return snap ? truncateSnap(snap) : null;\n  }\n\n  /**\n   * Gets the snap with the given id, throw if it doesn't exist.\n   *\n   * @throws {@link Error}. If snap doesn't exist\n   * @param snapId - The id of the snap to get.\n   * @returns A truncated version of the snap state, that is less expensive to serialize.\n   */\n  getTruncatedExpect(snapId: SnapId): TruncatedSnap {\n    return truncateSnap(this.getExpect(snapId));\n  }\n\n  /**\n   * Generate an encryption key to be used for state encryption for a given Snap.\n   *\n   * @param options - An options bag.\n   * @param options.snapId - The Snap ID.\n   * @param options.salt - A salt to be used for the encryption key.\n   * @param options.useCache - Whether to use caching or not.\n   * @param options.keyMetadata - Optional metadata about how to derive the encryption key.\n   * @returns An encryption key.\n   */\n  async #getSnapEncryptionKey({\n    snapId,\n    salt: passedSalt,\n    useCache,\n    keyMetadata,\n  }: {\n    snapId: SnapId;\n    salt?: string;\n    useCache: boolean;\n    keyMetadata?: KeyDerivationOptions;\n  }): Promise<{ key: unknown; salt: string }> {\n    const runtime = this.#getRuntimeExpect(snapId);\n\n    if (runtime.encryptionKey && runtime.encryptionSalt && useCache) {\n      return {\n        key: await this.#encryptor.importKey(runtime.encryptionKey),\n        salt: runtime.encryptionSalt,\n      };\n    }\n\n    const salt = passedSalt ?? this.#encryptor.generateSalt();\n    const mnemonicPhrase = await this.#getMnemonic();\n    const entropy = await getEncryptionEntropy({ snapId, mnemonicPhrase });\n    const encryptionKey = await this.#encryptor.keyFromPassword(\n      entropy,\n      salt,\n      true,\n      keyMetadata,\n    );\n    const exportedKey = await this.#encryptor.exportKey(encryptionKey);\n\n    // Cache exported encryption key in runtime\n    if (useCache) {\n      runtime.encryptionKey = exportedKey;\n      runtime.encryptionSalt = salt;\n    }\n    return { key: encryptionKey, salt };\n  }\n\n  /**\n   * Decrypt the encrypted state for a given Snap.\n   *\n   * @param snapId - The Snap ID.\n   * @param state - The encrypted state as a string.\n   * @returns A valid JSON object derived from the encrypted state.\n   * @throws If the decryption fails or the decrypted state is not valid JSON.\n   */\n  async #decryptSnapState(snapId: SnapId, state: string) {\n    try {\n      const parsed = parseJson<EncryptionResult>(state);\n      const { salt, keyMetadata } = parsed;\n      const useCache = this.#encryptor.isVaultUpdated(state);\n      const { key } = await this.#getSnapEncryptionKey({\n        snapId,\n        salt,\n        useCache,\n        // When decrypting state we expect key metadata to be present.\n        // If it isn't present, we assume that the Snap state we are decrypting is old enough to use the legacy encryption params.\n        keyMetadata: keyMetadata ?? LEGACY_ENCRYPTION_KEY_DERIVATION_OPTIONS,\n      });\n      const decryptedState = await this.#encryptor.decryptWithKey(key, parsed);\n\n      assert(isValidJson(decryptedState));\n\n      return decryptedState as Record<string, Json>;\n    } catch {\n      throw rpcErrors.internal({\n        message: 'Failed to decrypt snap state, the state must be corrupted.',\n      });\n    }\n  }\n\n  /**\n   * Encrypt a JSON state object for a given Snap.\n   *\n   * Note: This function does not assert the validity of the object,\n   * please ensure only valid JSON is passed to it.\n   *\n   * @param snapId - The Snap ID.\n   * @param state - The state object.\n   * @returns A string containing the encrypted JSON object.\n   */\n  async #encryptSnapState(snapId: SnapId, state: Record<string, Json>) {\n    const { key, salt } = await this.#getSnapEncryptionKey({\n      snapId,\n      useCache: true,\n    });\n    const encryptedState = await this.#encryptor.encryptWithKey(key, state);\n\n    encryptedState.salt = salt;\n    return JSON.stringify(encryptedState);\n  }\n\n  /**\n   * Updates the own state of the snap with the given id.\n   * This is distinct from the state MetaMask uses to manage snaps.\n   *\n   * @param snapId - The id of the Snap whose state should be updated.\n   * @param newSnapState - The new state of the snap.\n   * @param encrypted - A flag to indicate whether to use encrypted storage or not.\n   */\n  async updateSnapState(\n    snapId: SnapId,\n    newSnapState: Record<string, Json>,\n    encrypted: boolean,\n  ) {\n    if (encrypted) {\n      const encryptedState = await this.#encryptSnapState(snapId, newSnapState);\n\n      this.update((state) => {\n        state.snapStates[snapId] = encryptedState;\n      });\n    } else {\n      this.update((state) => {\n        state.unencryptedSnapStates[snapId] = JSON.stringify(newSnapState);\n      });\n    }\n  }\n\n  /**\n   * Clears the state of the snap with the given id.\n   * This is distinct from the state MetaMask uses to manage snaps.\n   *\n   * @param snapId - The id of the Snap whose state should be cleared.\n   * @param encrypted - A flag to indicate whether to use encrypted storage or not.\n   */\n  clearSnapState(snapId: SnapId, encrypted: boolean) {\n    this.update((state) => {\n      if (encrypted) {\n        state.snapStates[snapId] = null;\n      } else {\n        state.unencryptedSnapStates[snapId] = null;\n      }\n    });\n  }\n\n  /**\n   * Gets the own state of the snap with the given id.\n   * This is distinct from the state MetaMask uses to manage snaps.\n   *\n   * @param snapId - The id of the Snap whose state to get.\n   * @param encrypted - A flag to indicate whether to use encrypted storage or not.\n   * @returns The requested snap state or null if no state exists.\n   */\n  async getSnapState(snapId: SnapId, encrypted: boolean): Promise<Json> {\n    const state = encrypted\n      ? this.state.snapStates[snapId]\n      : this.state.unencryptedSnapStates[snapId];\n\n    if (state === null || state === undefined) {\n      return null;\n    }\n\n    if (!encrypted) {\n      return parseJson(state);\n    }\n\n    const decrypted = await this.#decryptSnapState(snapId, state);\n    return decrypted;\n  }\n\n  /**\n   * Gets a static auxiliary snap file in a chosen file encoding.\n   *\n   * @param snapId - The id of the Snap whose state to get.\n   * @param path - The path to the requested file.\n   * @param encoding - An optional requested file encoding.\n   * @returns The file requested in the chosen file encoding or null if the file is not found.\n   */\n  async getSnapFile(\n    snapId: SnapId,\n    path: string,\n    encoding: AuxiliaryFileEncoding = AuxiliaryFileEncoding.Base64,\n  ): Promise<string | null> {\n    const snap = this.getExpect(snapId);\n    const normalizedPath = normalizeRelative(path);\n    const value = snap.auxiliaryFiles?.find(\n      (file) => file.path === normalizedPath,\n    )?.value;\n\n    if (!value) {\n      return null;\n    }\n\n    return encodeAuxiliaryFile(value, encoding);\n  }\n\n  /**\n   * Completely clear the controller's state: delete all associated data,\n   * handlers, event listeners, and permissions; tear down all snap providers.\n   */\n  async clearState() {\n    const snapIds = Object.keys(this.state.snaps);\n    if (this.#closeAllConnections) {\n      snapIds.forEach((snapId) => {\n        this.#closeAllConnections?.(snapId);\n      });\n    }\n\n    await this.messagingSystem.call('ExecutionService:terminateAllSnaps');\n    snapIds.forEach((snapId) => this.#revokeAllSnapPermissions(snapId));\n\n    this.update((state: any) => {\n      state.snaps = {};\n      state.snapStates = {};\n    });\n\n    this.#snapsRuntimeData.clear();\n\n    // We want to remove all snaps & permissions, except for preinstalled snaps\n    if (this.#preinstalledSnaps) {\n      this.#handlePreinstalledSnaps(this.#preinstalledSnaps);\n\n      Object.values(this.state?.snaps).forEach((snap) =>\n        this.#setupRuntime(snap.id),\n      );\n    }\n  }\n\n  /**\n   * Removes the given snap from state, and clears all associated handlers\n   * and listeners.\n   *\n   * @param snapId - The id of the Snap.\n   * @returns A promise that resolves once the snap has been removed.\n   */\n  async removeSnap(snapId: SnapId): Promise<void> {\n    return this.removeSnaps([snapId]);\n  }\n\n  /**\n   * Stops the given snaps, removes them from state, and clears all associated\n   * permissions, handlers, and listeners.\n   *\n   * @param snapIds - The ids of the Snaps.\n   */\n  async removeSnaps(snapIds: SnapId[]): Promise<void> {\n    if (!Array.isArray(snapIds)) {\n      throw new Error('Expected array of snap ids.');\n    }\n\n    snapIds.forEach((snapId) => {\n      const snap = this.getExpect(snapId);\n      assert(snap.removable !== false, `${snapId} is not removable.`);\n    });\n\n    await Promise.all(\n      snapIds.map(async (snapId) => {\n        const snap = this.getExpect(snapId);\n        const truncated = this.getTruncatedExpect(snapId);\n        // Disable the snap and revoke all of its permissions before deleting\n        // it. This ensures that the snap will not be restarted or otherwise\n        // affect the host environment while we are deleting it.\n        await this.disableSnap(snapId);\n        this.#revokeAllSnapPermissions(snapId);\n\n        this.#removeSnapFromSubjects(snapId);\n\n        this.#snapsRuntimeData.delete(snapId);\n\n        this.update((state: any) => {\n          delete state.snaps[snapId];\n          delete state.snapStates[snapId];\n          delete state.unencryptedSnapStates[snapId];\n        });\n\n        // If the snap has been fully installed before, also emit snapUninstalled.\n        if (snap.status !== SnapStatus.Installing) {\n          this.messagingSystem.publish(\n            `SnapController:snapUninstalled`,\n            truncated,\n          );\n        }\n      }),\n    );\n  }\n\n  #handleInitialConnections(\n    snapId: SnapId,\n    previousInitialConnections: InitialConnections | null,\n    initialConnections: InitialConnections,\n  ) {\n    if (previousInitialConnections) {\n      const revokedInitialConnections = setDiff(\n        previousInitialConnections,\n        initialConnections,\n      );\n\n      for (const origin of Object.keys(revokedInitialConnections)) {\n        this.removeSnapFromSubject(origin, snapId);\n      }\n    }\n\n    for (const origin of Object.keys(initialConnections)) {\n      this.#addSnapToSubject(origin, snapId);\n    }\n  }\n\n  #addSnapToSubject(origin: string, snapId: SnapId) {\n    const subjectPermissions = this.messagingSystem.call(\n      'PermissionController:getPermissions',\n      origin,\n    ) as SubjectPermissions<PermissionConstraint>;\n\n    const existingCaveat = subjectPermissions?.[\n      WALLET_SNAP_PERMISSION_KEY\n    ]?.caveats?.find((caveat) => caveat.type === SnapCaveatType.SnapIds);\n\n    const subjectHasSnap = Boolean(\n      (existingCaveat?.value as Record<string, Json>)?.[snapId],\n    );\n\n    // If the subject is already connected to the snap, this is a no-op.\n    if (subjectHasSnap) {\n      return;\n    }\n\n    // If an existing caveat exists, we add the snap to that.\n    if (existingCaveat) {\n      this.messagingSystem.call(\n        'PermissionController:updateCaveat',\n        origin,\n        WALLET_SNAP_PERMISSION_KEY,\n        SnapCaveatType.SnapIds,\n        { ...(existingCaveat.value as Record<string, Json>), [snapId]: {} },\n      );\n      return;\n    }\n\n    const approvedPermissions = {\n      [WALLET_SNAP_PERMISSION_KEY]: {\n        caveats: [\n          {\n            type: SnapCaveatType.SnapIds,\n            value: {\n              [snapId]: {},\n            },\n          },\n        ],\n      },\n    } as RequestedPermissions;\n\n    this.messagingSystem.call('PermissionController:grantPermissions', {\n      approvedPermissions,\n      subject: { origin },\n    });\n  }\n\n  /**\n   * Removes a snap's permission (caveat) from the specified subject.\n   *\n   * @param origin - The origin from which to remove the snap.\n   * @param snapId - The id of the snap to remove.\n   */\n  removeSnapFromSubject(origin: string, snapId: SnapId) {\n    const subjectPermissions = this.messagingSystem.call(\n      'PermissionController:getPermissions',\n      origin,\n    ) as SubjectPermissions<PermissionConstraint>;\n\n    const snapIdsCaveat = subjectPermissions?.[\n      WALLET_SNAP_PERMISSION_KEY\n    ]?.caveats?.find((caveat) => caveat.type === SnapCaveatType.SnapIds) as\n      | Caveat<string, Json>\n      | undefined;\n\n    if (!snapIdsCaveat) {\n      return;\n    }\n\n    const caveatHasSnap = Boolean(\n      (snapIdsCaveat.value as Record<string, Json>)?.[snapId],\n    );\n    if (caveatHasSnap) {\n      const newCaveatValue = {\n        ...(snapIdsCaveat.value as Record<string, Json>),\n      };\n      delete newCaveatValue[snapId];\n      if (Object.keys(newCaveatValue).length > 0) {\n        this.messagingSystem.call(\n          'PermissionController:updateCaveat',\n          origin,\n          WALLET_SNAP_PERMISSION_KEY,\n          SnapCaveatType.SnapIds,\n          newCaveatValue,\n        );\n      } else {\n        this.messagingSystem.call('PermissionController:revokePermissions', {\n          [origin]: [WALLET_SNAP_PERMISSION_KEY],\n        });\n      }\n    }\n  }\n\n  /**\n   * Checks if a list of permissions are dynamic and allowed to be revoked, if they are they will all be revoked.\n   *\n   * @param snapId - The snap ID.\n   * @param permissionNames - The names of the permissions.\n   * @throws If non-dynamic permissions are passed.\n   */\n  revokeDynamicSnapPermissions(\n    snapId: string,\n    permissionNames: NonEmptyArray<string>,\n  ) {\n    assert(\n      permissionNames.every((permissionName) =>\n        this.#dynamicPermissions.includes(permissionName),\n      ),\n      'Non-dynamic permissions cannot be revoked',\n    );\n    this.messagingSystem.call('PermissionController:revokePermissions', {\n      [snapId]: permissionNames,\n    });\n  }\n\n  /**\n   * Removes a snap's permission (caveat) from all subjects.\n   *\n   * @param snapId - The id of the Snap.\n   */\n  #removeSnapFromSubjects(snapId: SnapId) {\n    const subjects = this.messagingSystem.call(\n      'PermissionController:getSubjectNames',\n    );\n    for (const subject of subjects) {\n      this.removeSnapFromSubject(subject, snapId);\n    }\n  }\n\n  /**\n   * Safely revokes all permissions granted to a Snap.\n   *\n   * @param snapId - The snap ID.\n   */\n  #revokeAllSnapPermissions(snapId: string) {\n    if (\n      this.messagingSystem.call('PermissionController:hasPermissions', snapId)\n    ) {\n      this.messagingSystem.call(\n        'PermissionController:revokeAllPermissions',\n        snapId,\n      );\n    }\n  }\n\n  /**\n   * Handles incrementing the activeReferences counter.\n   *\n   * @param snapId - The snap id of the snap that was referenced.\n   */\n  incrementActiveReferences(snapId: SnapId) {\n    const runtime = this.#getRuntimeExpect(snapId);\n    runtime.activeReferences += 1;\n  }\n\n  /**\n   * Handles decrement the activeReferences counter.\n   *\n   * @param snapId - The snap id of the snap that was referenced..\n   */\n  decrementActiveReferences(snapId: SnapId) {\n    const runtime = this.#getRuntimeExpect(snapId);\n    assert(\n      runtime.activeReferences > 0,\n      'SnapController reference management is in an invalid state.',\n    );\n    runtime.activeReferences -= 1;\n  }\n\n  /**\n   * Gets all snaps in their truncated format.\n   *\n   * @returns All installed snaps in their truncated format.\n   */\n  getAllSnaps(): TruncatedSnap[] {\n    return Object.values(this.state.snaps).map(truncateSnap);\n  }\n\n  /**\n   * Gets the serialized permitted snaps of the given origin, if any.\n   *\n   * @param origin - The origin whose permitted snaps to retrieve.\n   * @returns The serialized permitted snaps for the origin.\n   */\n  getPermittedSnaps(origin: string): RequestSnapsResult {\n    const permissions =\n      this.messagingSystem.call(\n        'PermissionController:getPermissions',\n        origin,\n      ) ?? {};\n    const snaps =\n      permissions[WALLET_SNAP_PERMISSION_KEY]?.caveats?.find(\n        (caveat) => caveat.type === SnapCaveatType.SnapIds,\n      )?.value ?? {};\n    return Object.keys(snaps).reduce<RequestSnapsResult>(\n      (permittedSnaps, snapId) => {\n        const snap = this.get(snapId);\n        const truncatedSnap = this.getTruncated(snapId as SnapId);\n\n        if (truncatedSnap && snap?.status !== SnapStatus.Installing) {\n          permittedSnaps[snapId] = truncatedSnap;\n        }\n        return permittedSnaps;\n      },\n      {},\n    );\n  }\n\n  /**\n   * Installs the snaps requested by the given origin, returning the snap\n   * object if the origin is permitted to install it, and an authorization error\n   * otherwise.\n   *\n   * @param origin - The origin that requested to install the snaps.\n   * @param requestedSnaps - The snaps to install.\n   * @returns An object of snap ids and snap objects, or errors if a\n   * snap couldn't be installed.\n   */\n  async installSnaps(\n    origin: string,\n    requestedSnaps: RequestSnapsParams,\n  ): Promise<RequestSnapsResult> {\n    this.#assertCanUsePlatform();\n\n    const result: RequestSnapsResult = {};\n\n    const snapIds = Object.keys(requestedSnaps);\n\n    const pendingUpdates = [];\n    const pendingInstalls = [];\n\n    try {\n      for (const [snapId, { version: rawVersion }] of Object.entries(\n        requestedSnaps,\n      )) {\n        assertIsValidSnapId(snapId);\n\n        const [error, version] = resolveVersionRange(rawVersion);\n\n        if (error) {\n          throw rpcErrors.invalidParams(\n            `The \"version\" field must be a valid SemVer version range if specified. Received: \"${\n              rawVersion as string\n            }\".`,\n          );\n        }\n\n        const location = this.#detectSnapLocation(snapId, {\n          versionRange: version,\n          fetch: this.#fetchFunction,\n          allowLocal: this.#featureFlags.allowLocalSnaps,\n          resolveVersion: async (range) =>\n            this.#featureFlags.requireAllowlist\n              ? await this.#resolveAllowlistVersion(snapId, range)\n              : range,\n        });\n\n        // Existing snaps may need to be updated, unless they should be re-installed (e.g. local snaps)\n        // Everything else is treated as an install\n        const isUpdate = this.has(snapId) && !location.shouldAlwaysReload;\n\n        if (isUpdate && this.#isValidUpdate(snapId, version)) {\n          const existingSnap = this.getExpect(snapId);\n          pendingUpdates.push({ snapId, oldVersion: existingSnap.version });\n          let rollbackSnapshot = this.#getRollbackSnapshot(snapId);\n          if (rollbackSnapshot === undefined) {\n            rollbackSnapshot = this.#createRollbackSnapshot(snapId);\n            rollbackSnapshot.newVersion = version;\n          } else {\n            throw new Error('This snap is already being updated.');\n          }\n        } else if (!isUpdate) {\n          pendingInstalls.push(snapId);\n        }\n\n        result[snapId] = await this.processRequestedSnap(\n          origin,\n          snapId,\n          location,\n          version,\n        );\n      }\n\n      // Once we finish all installs / updates, emit events.\n      pendingInstalls.forEach((snapId) =>\n        this.messagingSystem.publish(\n          `SnapController:snapInstalled`,\n          this.getTruncatedExpect(snapId),\n          origin,\n        ),\n      );\n\n      pendingUpdates.forEach(({ snapId, oldVersion }) =>\n        this.messagingSystem.publish(\n          `SnapController:snapUpdated`,\n          this.getTruncatedExpect(snapId),\n          oldVersion,\n          origin,\n        ),\n      );\n\n      snapIds.forEach((snapId) => this.#rollbackSnapshots.delete(snapId));\n    } catch (error) {\n      const installed = pendingInstalls.filter((snapId) => this.has(snapId));\n      await this.removeSnaps(installed);\n      const snapshottedSnaps = [...this.#rollbackSnapshots.keys()];\n      const snapsToRollback = pendingUpdates\n        .map(({ snapId }) => snapId)\n        .filter((snapId) => snapshottedSnaps.includes(snapId));\n      await this.#rollbackSnaps(snapsToRollback);\n\n      throw error;\n    }\n\n    return result;\n  }\n\n  /**\n   * Adds, authorizes, and runs the given snap with a snap provider.\n   * Results from this method should be efficiently serializable.\n   *\n   * @param origin - The origin requesting the snap.\n   * @param snapId - The id of the snap.\n   * @param location - The location implementation of the snap.\n   * @param versionRange - The semver range of the snap to install.\n   * @returns The resulting snap object, or an error if something went wrong.\n   */\n  private async processRequestedSnap(\n    origin: string,\n    snapId: SnapId,\n    location: SnapLocation,\n    versionRange: SemVerRange,\n  ): Promise<TruncatedSnap> {\n    const existingSnap = this.getTruncated(snapId);\n\n    // For devX we always re-install local snaps.\n    if (existingSnap && !location.shouldAlwaysReload) {\n      if (satisfiesVersionRange(existingSnap.version, versionRange)) {\n        return existingSnap;\n      }\n\n      return await this.updateSnap(\n        origin,\n        snapId,\n        location,\n        versionRange,\n        // Since we are requesting an update from within processRequestedSnap,\n        // we disable the emitting of the snapUpdated event and rely on the caller\n        // to publish this event after the update is complete.\n        // This is necessary as installSnaps may be installing multiple snaps\n        // and we don't want to emit events prematurely.\n        false,\n      );\n    }\n\n    this.#assertCanInstallSnaps();\n\n    let pendingApproval = this.#createApproval({\n      origin,\n      snapId,\n      type: SNAP_APPROVAL_INSTALL,\n    });\n\n    this.messagingSystem.publish(\n      'SnapController:snapInstallStarted',\n      snapId,\n      origin,\n      false,\n    );\n\n    // Existing snaps must be stopped before overwriting\n    if (existingSnap && this.isRunning(snapId)) {\n      await this.stopSnap(snapId, SnapStatusEvents.Stop);\n    }\n\n    // Existing snaps that should be re-installed should not maintain their existing permissions\n    if (existingSnap && location.shouldAlwaysReload) {\n      this.#revokeAllSnapPermissions(snapId);\n    }\n\n    try {\n      const { sourceCode } = await this.#add({\n        origin,\n        id: snapId,\n        location,\n        versionRange,\n      });\n\n      await this.authorize(snapId, pendingApproval);\n\n      pendingApproval = this.#createApproval({\n        origin,\n        snapId,\n        type: SNAP_APPROVAL_RESULT,\n      });\n\n      await this.#startSnap({\n        snapId,\n        sourceCode,\n      });\n\n      const truncated = this.getTruncatedExpect(snapId);\n\n      this.#updateApproval(pendingApproval.id, {\n        loading: false,\n        type: SNAP_APPROVAL_INSTALL,\n      });\n\n      return truncated;\n    } catch (error) {\n      logError(`Error when adding ${snapId}.`, error);\n\n      const errorString =\n        error instanceof Error ? error.message : error.toString();\n\n      this.#updateApproval(pendingApproval.id, {\n        loading: false,\n        type: SNAP_APPROVAL_INSTALL,\n        error: errorString,\n      });\n\n      this.messagingSystem.publish(\n        'SnapController:snapInstallFailed',\n        snapId,\n        origin,\n        false,\n        errorString,\n      );\n\n      throw error;\n    }\n  }\n\n  #createApproval({\n    origin,\n    snapId,\n    type,\n  }: {\n    origin: string;\n    snapId: SnapId;\n    type: string;\n  }): PendingApproval {\n    const id = nanoid();\n    const promise = this.messagingSystem.call(\n      'ApprovalController:addRequest',\n      {\n        origin,\n        id,\n        type,\n        requestData: {\n          // Mirror previous installation metadata\n          metadata: { id, origin: snapId, dappOrigin: origin },\n          snapId,\n        },\n        requestState: {\n          loading: true,\n        },\n      },\n      true,\n    );\n\n    return { id, promise };\n  }\n\n  #updateApproval(id: string, requestState: Record<string, Json>) {\n    try {\n      this.messagingSystem.call('ApprovalController:updateRequestState', {\n        id,\n        requestState,\n      });\n    } catch {\n      // Do nothing\n    }\n  }\n\n  /**\n   * Updates an installed snap. The flow is similar to\n   * {@link SnapController.installSnaps}. The user will be asked if they want\n   * to update, then approve any permission changes, and finally the snap will\n   * be restarted.\n   *\n   * The update will fail if the user rejects any prompt or if the new version\n   * of the snap is blocked.\n   *\n   * If the original version of the snap was blocked and the update succeeded,\n   * the snap will be unblocked and enabled before it is restarted.\n   *\n   * @param origin - The origin requesting the snap update.\n   * @param snapId - The id of the Snap to be updated.\n   * @param location - The location implementation of the snap.\n   * @param newVersionRange - A semver version range in which the maximum version will be chosen.\n   * @param emitEvent - An optional boolean flag to indicate whether this update should emit an event.\n   * @returns The snap metadata if updated, `null` otherwise.\n   */\n  async updateSnap(\n    origin: string,\n    snapId: SnapId,\n    location: SnapLocation,\n    newVersionRange: string = DEFAULT_REQUESTED_SNAP_VERSION,\n    emitEvent = true,\n  ): Promise<TruncatedSnap> {\n    this.#assertCanInstallSnaps();\n    this.#assertCanUsePlatform();\n    if (!isValidSemVerRange(newVersionRange)) {\n      throw new Error(\n        `Received invalid snap version range: \"${newVersionRange}\".`,\n      );\n    }\n\n    let pendingApproval = this.#createApproval({\n      origin,\n      snapId,\n      type: SNAP_APPROVAL_UPDATE,\n    });\n\n    try {\n      this.messagingSystem.publish(\n        'SnapController:snapInstallStarted',\n        snapId,\n        origin,\n        true,\n      );\n\n      const snap = this.getExpect(snapId);\n\n      const oldManifest = snap.manifest;\n\n      const newSnap = await fetchSnap(snapId, location);\n      const { sourceCode: sourceCodeFile, manifest: manifestFile } = newSnap;\n\n      const manifest = manifestFile.result;\n\n      const newVersion = manifest.version;\n      if (!gtVersion(newVersion, snap.version)) {\n        throw rpcErrors.invalidParams(\n          `Snap \"${snapId}@${snap.version}\" is already installed. Couldn't update to a version inside requested \"${newVersionRange}\" range.`,\n        );\n      }\n\n      if (!satisfiesVersionRange(newVersion, newVersionRange)) {\n        throw new Error(\n          `Version mismatch. Manifest for \"${snapId}\" specifies version \"${newVersion}\" which doesn't satisfy requested version range \"${newVersionRange}\".`,\n        );\n      }\n\n      await this.#assertIsInstallAllowed(snapId, {\n        version: newVersion,\n        checksum: manifest.source.shasum,\n        permissions: manifest.initialPermissions,\n      });\n\n      const processedPermissions = processSnapPermissions(\n        manifest.initialPermissions,\n      );\n\n      this.#validateSnapPermissions(processedPermissions);\n\n      const { newPermissions, unusedPermissions, approvedPermissions } =\n        this.#calculatePermissionsChange(snapId, processedPermissions);\n\n      const { newConnections, unusedConnections, approvedConnections } =\n        calculateConnectionsChange(\n          oldManifest.initialConnections ?? {},\n          manifest.initialConnections ?? {},\n        );\n\n      this.#updateApproval(pendingApproval.id, {\n        permissions: newPermissions,\n        newVersion: manifest.version,\n        newPermissions,\n        approvedPermissions,\n        unusedPermissions,\n        newConnections,\n        unusedConnections,\n        approvedConnections,\n        loading: false,\n      });\n\n      const { permissions: approvedNewPermissions, ...requestData } =\n        (await pendingApproval.promise) as PermissionsRequest;\n\n      pendingApproval = this.#createApproval({\n        origin,\n        snapId,\n        type: SNAP_APPROVAL_RESULT,\n      });\n\n      if (this.isRunning(snapId)) {\n        await this.stopSnap(snapId, SnapStatusEvents.Stop);\n      }\n\n      this.#transition(snapId, SnapStatusEvents.Update);\n\n      this.#set({\n        origin,\n        id: snapId,\n        files: newSnap,\n        isUpdate: true,\n      });\n\n      this.#updatePermissions({\n        snapId,\n        unusedPermissions,\n        newPermissions: approvedNewPermissions,\n        requestData,\n      });\n\n      if (manifest.initialConnections) {\n        this.#handleInitialConnections(\n          snapId,\n          oldManifest.initialConnections ?? null,\n          manifest.initialConnections,\n        );\n      }\n\n      const rollbackSnapshot = this.#getRollbackSnapshot(snapId);\n      if (rollbackSnapshot !== undefined) {\n        rollbackSnapshot.permissions.revoked = unusedPermissions;\n        rollbackSnapshot.permissions.granted = approvedNewPermissions;\n        rollbackSnapshot.permissions.requestData = requestData;\n      }\n\n      const sourceCode = sourceCodeFile.toString();\n\n      assert(\n        typeof sourceCode === 'string' && sourceCode.length > 0,\n        `Invalid source code for snap \"${snapId}\".`,\n      );\n\n      try {\n        await this.#startSnap({ snapId, sourceCode });\n      } catch {\n        throw new Error(`Snap ${snapId} crashed with updated source code.`);\n      }\n\n      const truncatedSnap = this.getTruncatedExpect(snapId);\n\n      if (emitEvent) {\n        this.messagingSystem.publish(\n          'SnapController:snapUpdated',\n          truncatedSnap,\n          snap.version,\n          origin,\n        );\n      }\n\n      this.#updateApproval(pendingApproval.id, {\n        loading: false,\n        type: SNAP_APPROVAL_UPDATE,\n      });\n\n      return truncatedSnap;\n    } catch (error) {\n      logError(`Error when updating ${snapId},`, error);\n\n      const errorString =\n        error instanceof Error ? error.message : error.toString();\n\n      this.#updateApproval(pendingApproval.id, {\n        loading: false,\n        error: errorString,\n        type: SNAP_APPROVAL_UPDATE,\n      });\n\n      this.messagingSystem.publish(\n        'SnapController:snapInstallFailed',\n        snapId,\n        origin,\n        true,\n        errorString,\n      );\n\n      throw error;\n    }\n  }\n\n  async #resolveAllowlistVersion(\n    snapId: SnapId,\n    versionRange: SemVerRange,\n  ): Promise<SemVerRange> {\n    return await this.messagingSystem.call(\n      'SnapsRegistry:resolveVersion',\n      snapId,\n      versionRange,\n    );\n  }\n\n  /**\n   * Get metadata for the given snap ID.\n   *\n   * @param snapId - The ID of the snap to get metadata for.\n   * @returns The metadata for the given snap ID, or `null` if the snap is not\n   * verified.\n   */\n  async getRegistryMetadata(\n    snapId: SnapId,\n  ): Promise<SnapsRegistryMetadata | null> {\n    this.#assertCanUsePlatform();\n    return await this.messagingSystem.call('SnapsRegistry:getMetadata', snapId);\n  }\n\n  /**\n   * Returns a promise representing the complete installation of the requested snap.\n   * If the snap is already being installed, the previously pending promise will be returned.\n   *\n   * @param args - Object containing the snap id and either the URL of the snap's manifest,\n   * or the snap's manifest and source code. The object may also optionally contain a target\n   * version.\n   * @returns The resulting snap object.\n   */\n  async #add(args: AddSnapArgs): Promise<PersistedSnap> {\n    const { id: snapId, location, versionRange } = args;\n\n    this.#setupRuntime(snapId);\n    const runtime = this.#getRuntimeExpect(snapId);\n    if (!runtime.installPromise) {\n      log(`Adding snap: ${snapId}`);\n\n      // If fetching and setting the snap succeeds, this property will be set\n      // to null in the authorize() method.\n      runtime.installPromise = (async () => {\n        const fetchedSnap = await fetchSnap(snapId, location);\n        const manifest = fetchedSnap.manifest.result;\n        if (!satisfiesVersionRange(manifest.version, versionRange)) {\n          throw new Error(\n            `Version mismatch. Manifest for \"${snapId}\" specifies version \"${manifest.version}\" which doesn't satisfy requested version range \"${versionRange}\".`,\n          );\n        }\n\n        await this.#assertIsInstallAllowed(snapId, {\n          version: manifest.version,\n          checksum: manifest.source.shasum,\n          permissions: manifest.initialPermissions,\n        });\n\n        return this.#set({\n          ...args,\n          files: fetchedSnap,\n          id: snapId,\n        });\n      })();\n    }\n\n    try {\n      return await runtime.installPromise;\n    } catch (error) {\n      // Reset promise so users can retry installation in case the problem is\n      // temporary.\n      runtime.installPromise = null;\n      throw error;\n    }\n  }\n\n  async #startSnap(snapData: { snapId: SnapId; sourceCode: string }) {\n    const { snapId } = snapData;\n    if (this.isRunning(snapId)) {\n      throw new Error(`Snap \"${snapId}\" is already started.`);\n    }\n\n    try {\n      const runtime = this.#getRuntimeExpect(snapId);\n      const result = await this.messagingSystem.call(\n        'ExecutionService:executeSnap',\n        {\n          ...snapData,\n          endowments: await this.#getEndowments(snapId),\n        },\n      );\n\n      this.#transition(snapId, SnapStatusEvents.Start);\n      // We treat the initialization of the snap as the first request, for idle timing purposes.\n      runtime.lastRequest = Date.now();\n      return result;\n    } catch (error) {\n      await this.#terminateSnap(snapId);\n      throw error;\n    }\n  }\n\n  /**\n   * Gets the names of all endowments that will be added to the Snap's\n   * Compartment when it executes. These should be the names of global\n   * JavaScript APIs accessible in the root realm of the execution environment.\n   *\n   * Throws an error if the endowment getter for a permission returns a truthy\n   * value that is not an array of strings.\n   *\n   * @param snapId - The id of the snap whose SES endowments to get.\n   * @returns An array of the names of the endowments.\n   */\n  async #getEndowments(snapId: string): Promise<string[]> {\n    let allEndowments: string[] = [];\n\n    for (const permissionName of this.#environmentEndowmentPermissions) {\n      if (\n        this.messagingSystem.call(\n          'PermissionController:hasPermission',\n          snapId,\n          permissionName,\n        )\n      ) {\n        const endowments = await this.messagingSystem.call(\n          'PermissionController:getEndowments',\n          snapId,\n          permissionName,\n        );\n\n        if (endowments) {\n          // We don't have any guarantees about the type of the endowments\n          // value, so we have to guard at runtime.\n          if (\n            !Array.isArray(endowments) ||\n            endowments.some((value) => typeof value !== 'string')\n          ) {\n            throw new Error('Expected an array of string endowment names.');\n          }\n\n          allEndowments = allEndowments.concat(endowments as string[]);\n        }\n      }\n    }\n\n    const dedupedEndowments = [\n      ...new Set([...DEFAULT_ENDOWMENTS, ...allEndowments]),\n    ];\n\n    if (\n      dedupedEndowments.length <\n      // This is a bug in TypeScript: https://github.com/microsoft/TypeScript/issues/48313\n      // eslint-disable-next-line @typescript-eslint/restrict-plus-operands\n      DEFAULT_ENDOWMENTS.length + allEndowments.length\n    ) {\n      logError(\n        `Duplicate endowments found for ${snapId}. Default endowments should not be requested.`,\n        allEndowments,\n      );\n    }\n    return dedupedEndowments;\n  }\n\n  /**\n   * Sets a snap in state. Called when a snap is installed or updated. Performs\n   * various validation checks on the received arguments, and will throw if\n   * validation fails.\n   *\n   * The snap will be enabled and unblocked by the time this method returns,\n   * regardless of its previous state.\n   *\n   * See {@link SnapController.add} and {@link SnapController.updateSnap} for\n   * usage.\n   *\n   * @param args - The add snap args.\n   * @returns The resulting snap object.\n   */\n  #set(args: SetSnapArgs): PersistedSnap {\n    const {\n      id: snapId,\n      origin,\n      files,\n      isUpdate = false,\n      removable,\n      preinstalled,\n      hidden,\n    } = args;\n\n    const {\n      manifest,\n      sourceCode: sourceCodeFile,\n      svgIcon,\n      auxiliaryFiles: rawAuxiliaryFiles,\n      localizationFiles,\n    } = files;\n\n    assertIsSnapManifest(manifest.result);\n    const { version } = manifest.result;\n\n    const sourceCode = sourceCodeFile.toString();\n\n    assert(\n      typeof sourceCode === 'string' && sourceCode.length > 0,\n      `Invalid source code for snap \"${snapId}\".`,\n    );\n\n    const auxiliaryFiles = rawAuxiliaryFiles.map((file) => {\n      assert(typeof file.data.base64 === 'string');\n      return {\n        path: file.path,\n        value: file.data.base64,\n      };\n    });\n\n    const snapsState = this.state.snaps;\n\n    const existingSnap = snapsState[snapId];\n\n    const previousVersionHistory = existingSnap?.versionHistory ?? [];\n    const versionHistory = [\n      ...previousVersionHistory,\n      {\n        version,\n        date: Date.now(),\n        origin,\n      },\n    ];\n\n    const localizedFiles = localizationFiles.map((file) => file.result);\n\n    const snap: Snap = {\n      // Restore relevant snap state if it exists\n      ...existingSnap,\n\n      // Note that the snap will be unblocked and enabled, regardless of its\n      // previous state.\n      blocked: false,\n      enabled: true,\n\n      removable,\n      preinstalled,\n      hidden,\n\n      id: snapId,\n      initialConnections: manifest.result.initialConnections,\n      initialPermissions: manifest.result.initialPermissions,\n      manifest: manifest.result,\n      status: this.#statusMachine.config.initial as StatusStates['value'],\n      sourceCode,\n      version,\n      versionHistory,\n      auxiliaryFiles,\n      localizationFiles: localizedFiles,\n    };\n\n    // If the snap was blocked, it isn't any longer\n    delete snap.blockInformation;\n\n    // store the snap back in state\n    const { inversePatches } = this.update((state: any) => {\n      state.snaps[snapId] = snap;\n    });\n\n    // checking for isUpdate here as this function is also used in\n    // the install flow, we do not care to create snapshots for installs\n    if (isUpdate) {\n      const rollbackSnapshot = this.#getRollbackSnapshot(snapId);\n      if (rollbackSnapshot !== undefined) {\n        rollbackSnapshot.statePatches = inversePatches;\n      }\n    }\n\n    // In case the Snap uses a localized manifest, we need to get the\n    // proposed name from the localized manifest.\n    const { proposedName } = getLocalizedSnapManifest(\n      manifest.result,\n      'en',\n      localizedFiles,\n    );\n\n    this.messagingSystem.call('SubjectMetadataController:addSubjectMetadata', {\n      subjectType: SubjectType.Snap,\n      name: proposedName,\n      origin: snap.id,\n      version,\n      svgIcon: svgIcon?.toString() ?? null,\n    });\n\n    return { ...snap, sourceCode };\n  }\n\n  #validateSnapPermissions(\n    processedPermissions: Record<string, Pick<PermissionConstraint, 'caveats'>>,\n  ) {\n    const permissionKeys = Object.keys(processedPermissions);\n    const handlerPermissions = Array.from(\n      new Set(Object.values(handlerEndowments)),\n    );\n\n    assert(\n      permissionKeys.some((key) => handlerPermissions.includes(key)),\n      `A snap must request at least one of the following permissions: ${handlerPermissions\n        .filter((handler) => handler !== null)\n        .join(', ')}.`,\n    );\n\n    const excludedPermissionErrors = permissionKeys.reduce<string[]>(\n      (errors, permission) => {\n        if (hasProperty(this.#excludedPermissions, permission)) {\n          errors.push(this.#excludedPermissions[permission]);\n        }\n\n        return errors;\n      },\n      [],\n    );\n\n    assert(\n      excludedPermissionErrors.length === 0,\n      `One or more permissions are not allowed:\\n${excludedPermissionErrors.join(\n        '\\n',\n      )}`,\n    );\n  }\n\n  /**\n   * Initiates a request for the given snap's initial permissions.\n   * Must be called in order. See processRequestedSnap.\n   *\n   * This function is not hash private yet because of tests.\n   *\n   * @param snapId - The id of the Snap.\n   * @param pendingApproval - Pending approval to update.\n   * @returns The snap's approvedPermissions.\n   */\n  private async authorize(\n    snapId: SnapId,\n    pendingApproval: PendingApproval,\n  ): Promise<void> {\n    log(`Authorizing snap: ${snapId}`);\n    const snapsState = this.state.snaps;\n    const snap = snapsState[snapId];\n    const { initialPermissions, initialConnections } = snap;\n\n    try {\n      const processedPermissions = processSnapPermissions(initialPermissions);\n\n      this.#validateSnapPermissions(processedPermissions);\n\n      this.#updateApproval(pendingApproval.id, {\n        loading: false,\n        connections: initialConnections ?? {},\n        permissions: processedPermissions,\n      });\n\n      const { permissions: approvedPermissions, ...requestData } =\n        (await pendingApproval.promise) as PermissionsRequest;\n\n      this.#updatePermissions({\n        snapId,\n        newPermissions: approvedPermissions,\n        requestData,\n      });\n\n      if (snap.manifest.initialConnections) {\n        this.#handleInitialConnections(\n          snapId,\n          null,\n          snap.manifest.initialConnections,\n        );\n      }\n    } finally {\n      const runtime = this.#getRuntimeExpect(snapId);\n      runtime.installPromise = null;\n    }\n  }\n\n  destroy() {\n    super.destroy();\n\n    if (this.#timeoutForLastRequestStatus) {\n      clearTimeout(this.#timeoutForLastRequestStatus);\n    }\n\n    /* eslint-disable @typescript-eslint/unbound-method */\n    this.messagingSystem.unsubscribe(\n      'ExecutionService:unhandledError',\n      this._onUnhandledSnapError,\n    );\n\n    this.messagingSystem.unsubscribe(\n      'ExecutionService:outboundRequest',\n      this._onOutboundRequest,\n    );\n\n    this.messagingSystem.unsubscribe(\n      'ExecutionService:outboundResponse',\n      this._onOutboundResponse,\n    );\n\n    this.messagingSystem.clearEventSubscriptions(\n      'SnapController:snapInstalled',\n    );\n\n    this.messagingSystem.clearEventSubscriptions('SnapController:snapUpdated');\n    /* eslint-enable @typescript-eslint/unbound-method */\n  }\n\n  /**\n   * Passes a JSON-RPC request object to the RPC handler function of a snap.\n   *\n   * @param options - A bag of options.\n   * @param options.snapId - The ID of the recipient snap.\n   * @param options.origin - The origin of the RPC request.\n   * @param options.handler - The handler to trigger on the snap for the request.\n   * @param options.request - The JSON-RPC request object.\n   * @returns The result of the JSON-RPC request.\n   */\n  async handleRequest({\n    snapId,\n    origin,\n    handler: handlerType,\n    request: rawRequest,\n  }: SnapRpcHookArgs & { snapId: SnapId }): Promise<unknown> {\n    this.#assertCanUsePlatform();\n\n    const request = {\n      jsonrpc: '2.0',\n      id: nanoid(),\n      ...rawRequest,\n    };\n\n    assertIsJsonRpcRequest(request);\n\n    const permissionName = handlerEndowments[handlerType];\n\n    assert(\n      typeof permissionName === 'string' || permissionName === null,\n      \"'permissionName' must be either a string or null.\",\n    );\n\n    const permissions = this.messagingSystem.call(\n      'PermissionController:getPermissions',\n      snapId,\n    );\n\n    // If permissionName is null, the handler does not require a permission.\n    if (\n      permissionName !== null &&\n      (!permissions || !hasProperty(permissions, permissionName))\n    ) {\n      throw new Error(\n        `Snap \"${snapId}\" is not permitted to use \"${permissionName}\".`,\n      );\n    }\n\n    const handlerPermissions = permissionName\n      ? (permissions as SubjectPermissions<PermissionConstraint>)[\n          permissionName\n        ]\n      : undefined;\n\n    if (\n      permissionName === SnapEndowments.Rpc ||\n      permissionName === SnapEndowments.Keyring\n    ) {\n      assert(handlerPermissions);\n\n      const subject = this.messagingSystem.call(\n        'SubjectMetadataController:getSubjectMetadata',\n        origin,\n      );\n\n      const origins =\n        permissionName === SnapEndowments.Rpc\n          ? getRpcCaveatOrigins(handlerPermissions)\n          : getKeyringCaveatOrigins(handlerPermissions);\n      assert(origins);\n\n      if (\n        !isOriginAllowed(\n          origins,\n          subject?.subjectType ?? SubjectType.Website,\n          origin,\n        )\n      ) {\n        throw new Error(\n          `Snap \"${snapId}\" is not permitted to handle requests from \"${origin}\".`,\n        );\n      }\n    }\n\n    const handler = this.#getRpcRequestHandler(snapId);\n    if (!handler) {\n      throw new Error(\n        `Snap RPC message handler not found for snap \"${snapId}\".`,\n      );\n    }\n\n    const timeout = this.#getExecutionTimeout(handlerPermissions);\n\n    return handler({ origin, handler: handlerType, request, timeout });\n  }\n\n  /**\n   * Determine the execution timeout for a given handler permission.\n   *\n   * If no permission is specified or the permission itself has no execution timeout defined\n   * the constructor argument `maxRequestTime` will be used.\n   *\n   * @param permission - An optional permission constraint for the handler being called.\n   * @returns The execution timeout for the given handler.\n   */\n  #getExecutionTimeout(permission?: PermissionConstraint): number {\n    return getMaxRequestTimeCaveat(permission) ?? this.maxRequestTime;\n  }\n\n  /**\n   * Gets the RPC message handler for the given snap.\n   *\n   * @param snapId - The id of the Snap whose message handler to get.\n   * @returns The RPC handler for the given snap.\n   */\n  #getRpcRequestHandler(snapId: SnapId): SnapRpcHandler {\n    const runtime = this.#getRuntimeExpect(snapId);\n    const existingHandler = runtime.rpcHandler;\n    if (existingHandler) {\n      return existingHandler;\n    }\n\n    const requestQueue = new RequestQueue(5);\n    // We need to set up this promise map to map snapIds to their respective startPromises,\n    // because otherwise we would lose context on the correct startPromise.\n    const startPromises = new Map<string, Promise<void>>();\n\n    const rpcHandler = async ({\n      origin,\n      handler: handlerType,\n      request,\n      timeout,\n    }: SnapRpcHookArgs & { timeout: number }) => {\n      if (this.state.snaps[snapId].enabled === false) {\n        throw new Error(`Snap \"${snapId}\" is disabled.`);\n      }\n\n      if (this.state.snaps[snapId].status === SnapStatus.Installing) {\n        throw new Error(\n          `Snap \"${snapId}\" is currently being installed. Please try again later.`,\n        );\n      }\n\n      if (!this.isRunning(snapId)) {\n        let localStartPromise = startPromises.get(snapId);\n        if (!localStartPromise) {\n          localStartPromise = this.startSnap(snapId);\n          startPromises.set(snapId, localStartPromise);\n        } else if (requestQueue.get(origin) >= requestQueue.maxQueueSize) {\n          throw new Error(\n            'Exceeds maximum number of requests waiting to be resolved, please try again.',\n          );\n        }\n\n        requestQueue.increment(origin);\n        try {\n          await localStartPromise;\n        } finally {\n          requestQueue.decrement(origin);\n          // Only delete startPromise for a snap if its value hasn't changed\n          if (startPromises.get(snapId) === localStartPromise) {\n            startPromises.delete(snapId);\n          }\n        }\n      }\n\n      const timer = new Timer(timeout);\n      this.#recordSnapRpcRequestStart(snapId, request.id, timer);\n\n      const handleRpcRequestPromise = this.messagingSystem.call(\n        'ExecutionService:handleRpcRequest',\n        snapId,\n        { origin, handler: handlerType, request },\n      );\n\n      // This will either get the result or reject due to the timeout.\n      try {\n        const result = await withTimeout(handleRpcRequestPromise, timer);\n\n        if (result === hasTimedOut) {\n          throw new Error(\n            `${snapId} failed to respond to the request in time.`,\n          );\n        }\n\n        await this.#assertSnapRpcRequestResult(snapId, handlerType, result);\n\n        const transformedResult = await this.#transformSnapRpcRequestResult(\n          snapId,\n          handlerType,\n          result,\n        );\n\n        this.#recordSnapRpcRequestFinish(snapId, request.id);\n\n        return transformedResult;\n      } catch (error) {\n        // We flag the RPC request as finished early since termination may affect pending requests\n        this.#recordSnapRpcRequestFinish(snapId, request.id);\n        const [jsonRpcError, handled] = unwrapError(error);\n\n        if (!handled) {\n          await this.stopSnap(snapId, SnapStatusEvents.Crash);\n        }\n\n        throw jsonRpcError;\n      }\n    };\n\n    runtime.rpcHandler = rpcHandler;\n    return rpcHandler;\n  }\n\n  /**\n   * Create a dynamic interface in the SnapInterfaceController.\n   *\n   * @param snapId - The snap ID.\n   * @param content - The initial interface content.\n   * @returns An identifier that can be used to identify the interface.\n   */\n  async #createInterface(\n    snapId: SnapId,\n    content: ComponentOrElement,\n  ): Promise<string> {\n    return this.messagingSystem.call(\n      'SnapInterfaceController:createInterface',\n      snapId,\n      content,\n    );\n  }\n\n  #assertInterfaceExists(snapId: SnapId, id: string) {\n    // This will throw if the interface isn't accessible, but we assert nevertheless.\n    assert(\n      this.messagingSystem.call(\n        'SnapInterfaceController:getInterface',\n        snapId,\n        id,\n      ),\n    );\n  }\n\n  /**\n   * Transform a RPC request result if necessary.\n   *\n   * @param snapId - The snap ID of the snap that produced the result.\n   * @param handlerType - The handler type that produced the result.\n   * @param result - The result.\n   * @returns The transformed result if applicable, otherwise the original result.\n   */\n  async #transformSnapRpcRequestResult(\n    snapId: SnapId,\n    handlerType: HandlerType,\n    result: unknown,\n  ) {\n    switch (handlerType) {\n      case HandlerType.OnTransaction:\n      case HandlerType.OnSignature:\n      case HandlerType.OnHomePage: {\n        // Since this type has been asserted earlier we can cast\n        const castResult = result as Record<string, Json> | null;\n\n        // If a handler returns static content, we turn it into a dynamic UI\n        if (castResult && hasProperty(castResult, 'content')) {\n          const { content, ...rest } = castResult;\n\n          const id = await this.#createInterface(\n            snapId,\n            content as ComponentOrElement,\n          );\n\n          return { ...rest, id };\n        }\n        return result;\n      }\n      default:\n        return result;\n    }\n  }\n\n  /**\n   * Assert that the returned result of a Snap RPC call is the expected shape.\n   *\n   * @param snapId - The snap ID.\n   * @param handlerType - The handler type of the RPC Request.\n   * @param result - The result of the RPC request.\n   */\n  async #assertSnapRpcRequestResult(\n    snapId: SnapId,\n    handlerType: HandlerType,\n    result: unknown,\n  ) {\n    switch (handlerType) {\n      case HandlerType.OnTransaction: {\n        assertStruct(result, OnTransactionResponseStruct);\n\n        if (result && hasProperty(result, 'id')) {\n          this.#assertInterfaceExists(snapId, result.id as string);\n        }\n\n        break;\n      }\n      case HandlerType.OnSignature: {\n        assertStruct(result, OnSignatureResponseStruct);\n\n        if (result && hasProperty(result, 'id')) {\n          this.#assertInterfaceExists(snapId, result.id as string);\n        }\n\n        break;\n      }\n      case HandlerType.OnHomePage: {\n        assertStruct(result, OnHomePageResponseStruct);\n\n        if (result && hasProperty(result, 'id')) {\n          this.#assertInterfaceExists(snapId, result.id as string);\n        }\n\n        break;\n      }\n      case HandlerType.OnNameLookup:\n        assertStruct(result, OnNameLookupResponseStruct);\n        break;\n      default:\n        break;\n    }\n  }\n\n  #recordSnapRpcRequestStart(snapId: SnapId, requestId: unknown, timer: Timer) {\n    const runtime = this.#getRuntimeExpect(snapId);\n    runtime.pendingInboundRequests.push({ requestId, timer });\n    runtime.lastRequest = null;\n  }\n\n  #recordSnapRpcRequestFinish(snapId: SnapId, requestId: unknown) {\n    const runtime = this.#getRuntimeExpect(snapId);\n    runtime.pendingInboundRequests = runtime.pendingInboundRequests.filter(\n      (request) => request.requestId !== requestId,\n    );\n\n    if (runtime.pendingInboundRequests.length === 0) {\n      runtime.lastRequest = Date.now();\n    }\n  }\n\n  /**\n   * Retrieves the rollback snapshot of a snap.\n   *\n   * @param snapId - The snap id.\n   * @returns A `RollbackSnapshot` or `undefined` if one doesn't exist.\n   */\n  #getRollbackSnapshot(snapId: SnapId): RollbackSnapshot | undefined {\n    return this.#rollbackSnapshots.get(snapId);\n  }\n\n  /**\n   * Creates a `RollbackSnapshot` that is used to help ensure\n   * atomicity in multiple snap updates.\n   *\n   * @param snapId - The snap id.\n   * @throws {@link Error}. If the snap exists before creation or if creation fails.\n   * @returns A `RollbackSnapshot`.\n   */\n  #createRollbackSnapshot(snapId: SnapId): RollbackSnapshot {\n    assert(\n      this.#rollbackSnapshots.get(snapId) === undefined,\n      new Error(`Snap \"${snapId}\" rollback snapshot already exists.`),\n    );\n\n    this.#rollbackSnapshots.set(snapId, {\n      statePatches: [],\n      permissions: {},\n      newVersion: '',\n    });\n\n    const newRollbackSnapshot = this.#rollbackSnapshots.get(snapId);\n\n    assert(\n      newRollbackSnapshot !== undefined,\n      new Error(`Snapshot creation failed for ${snapId}.`),\n    );\n    return newRollbackSnapshot;\n  }\n\n  /**\n   * Rolls back a snap to its previous state, permissions\n   * and source code based on the `RollbackSnapshot` that\n   * is captured during the update process. After rolling back,\n   * the function also emits an event indicating that the\n   * snap has been rolled back and it clears the snapshot\n   * for that snap.\n   *\n   * @param snapId - The snap id.\n   * @throws {@link Error}. If a snapshot does not exist.\n   */\n  async #rollbackSnap(snapId: SnapId) {\n    const rollbackSnapshot = this.#getRollbackSnapshot(snapId);\n    if (!rollbackSnapshot) {\n      throw new Error('A snapshot does not exist for this snap.');\n    }\n\n    await this.stopSnap(snapId, SnapStatusEvents.Stop);\n    // Always set to stopped even if it wasn't running initially\n    if (this.get(snapId)?.status !== SnapStatus.Stopped) {\n      this.#transition(snapId, SnapStatusEvents.Stop);\n    }\n\n    const { statePatches, permissions } = rollbackSnapshot;\n\n    if (statePatches?.length) {\n      this.applyPatches(statePatches);\n    }\n\n    // Reset snap status, as we may have been in another state when we stored state patches\n    // But now we are 100% in a stopped state\n    if (this.get(snapId)?.status !== SnapStatus.Stopped) {\n      this.update((state) => {\n        state.snaps[snapId].status = SnapStatus.Stopped;\n      });\n    }\n\n    this.#updatePermissions({\n      snapId,\n      unusedPermissions: permissions.granted,\n      newPermissions: permissions.revoked,\n      requestData: permissions.requestData,\n    });\n\n    const truncatedSnap = this.getTruncatedExpect(snapId);\n\n    this.messagingSystem.publish(\n      'SnapController:snapRolledback',\n      truncatedSnap,\n      rollbackSnapshot.newVersion,\n    );\n\n    this.#rollbackSnapshots.delete(snapId);\n  }\n\n  /**\n   * Iterates through an array of snap ids\n   * and calls `rollbackSnap` on them.\n   *\n   * @param snapIds - An array of snap ids.\n   */\n  async #rollbackSnaps(snapIds: SnapId[]) {\n    for (const snapId of snapIds) {\n      await this.#rollbackSnap(snapId);\n    }\n  }\n\n  #getRuntime(snapId: SnapId): SnapRuntimeData | undefined {\n    return this.#snapsRuntimeData.get(snapId);\n  }\n\n  #getRuntimeExpect(snapId: SnapId): SnapRuntimeData {\n    const runtime = this.#getRuntime(snapId);\n    assert(\n      runtime !== undefined,\n      new Error(`Snap \"${snapId}\" runtime data not found`),\n    );\n    return runtime;\n  }\n\n  #setupRuntime(snapId: SnapId) {\n    if (this.#snapsRuntimeData.has(snapId)) {\n      return;\n    }\n\n    const snap = this.get(snapId);\n    const interpreter = interpret(this.#statusMachine);\n    interpreter.start({\n      context: { snapId },\n      value:\n        snap?.status ??\n        (this.#statusMachine.config.initial as StatusStates['value']),\n    });\n\n    forceStrict(interpreter);\n\n    this.#snapsRuntimeData.set(snapId, {\n      lastRequest: null,\n      rpcHandler: null,\n      installPromise: null,\n      encryptionKey: null,\n      encryptionSalt: null,\n      activeReferences: 0,\n      pendingInboundRequests: [],\n      pendingOutboundRequests: 0,\n      interpreter,\n      stopping: false,\n    });\n  }\n\n  #calculatePermissionsChange(\n    snapId: SnapId,\n    desiredPermissionsSet: Record<\n      string,\n      Pick<PermissionConstraint, 'caveats'>\n    >,\n  ): {\n    newPermissions: Record<string, Pick<PermissionConstraint, 'caveats'>>;\n    unusedPermissions: SubjectPermissions<\n      ValidPermission<string, Caveat<string, any>>\n    >;\n    approvedPermissions: SubjectPermissions<\n      ValidPermission<string, Caveat<string, any>>\n    >;\n  } {\n    const oldPermissions =\n      this.messagingSystem.call(\n        'PermissionController:getPermissions',\n        snapId,\n      ) ?? {};\n\n    const newPermissions = permissionsDiff(\n      desiredPermissionsSet,\n      oldPermissions,\n    );\n    // TODO(ritave): The assumption that these are unused only holds so long as we do not\n    //               permit dynamic permission requests.\n    const unusedPermissions = permissionsDiff(\n      oldPermissions,\n      desiredPermissionsSet,\n    );\n\n    // It's a Set Intersection of oldPermissions and desiredPermissionsSet\n    // oldPermissions  (oldPermissions  desiredPermissionsSet)  oldPermissions  desiredPermissionsSet\n    const approvedPermissions = permissionsDiff(\n      oldPermissions,\n      unusedPermissions,\n    );\n\n    return { newPermissions, unusedPermissions, approvedPermissions };\n  }\n\n  /**\n   * Updates the permissions for a snap following an install, update or rollback.\n   *\n   * Grants newly requested permissions and revokes unused/revoked permissions.\n   *\n   * @param args - An options bag.\n   * @param args.snapId - The snap ID.\n   * @param args.newPermissions - New permissions to be granted.\n   * @param args.unusedPermissions - Unused permissions to be revoked.\n   * @param args.requestData - Optional request data from an approval.\n   */\n  #updatePermissions({\n    snapId,\n    unusedPermissions = {},\n    newPermissions = {},\n    requestData,\n  }: {\n    snapId: SnapId;\n    newPermissions?:\n      | RequestedPermissions\n      | Record<string, Pick<PermissionConstraint, 'caveats'>>;\n    unusedPermissions?:\n      | RequestedPermissions\n      | SubjectPermissions<ValidPermission<string, Caveat<string, any>>>;\n    requestData?: Record<string, unknown>;\n  }) {\n    const unusedPermissionsKeys = Object.keys(unusedPermissions);\n    if (isNonEmptyArray(unusedPermissionsKeys)) {\n      this.messagingSystem.call('PermissionController:revokePermissions', {\n        [snapId]: unusedPermissionsKeys,\n      });\n    }\n\n    if (isNonEmptyArray(Object.keys(newPermissions))) {\n      this.messagingSystem.call('PermissionController:grantPermissions', {\n        approvedPermissions: newPermissions,\n        subject: { origin: snapId },\n        requestData,\n      });\n    }\n  }\n\n  /**\n   * Checks if a snap will pass version validation checks\n   * with the new version range that is requested. The first\n   * check that is done is to check if the existing snap version\n   * falls inside the requested range. If it does, we want to return\n   * false because we do not care to create a rollback snapshot in\n   * that scenario. The second check is to ensure that the current\n   * snap version is not greater than all possible versions in\n   * the requested version range. If it is, then we also want\n   * to return false in that scenario.\n   *\n   * @param snapId - The snap id.\n   * @param newVersionRange - The new version range being requested.\n   * @returns `true` if validation checks pass and `false` if they do not.\n   */\n  #isValidUpdate(snapId: SnapId, newVersionRange: SemVerRange): boolean {\n    const existingSnap = this.getExpect(snapId);\n\n    if (satisfiesVersionRange(existingSnap.version, newVersionRange)) {\n      return false;\n    }\n\n    if (gtRange(existingSnap.version, newVersionRange)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Call a lifecycle hook on a snap, if the snap has the\n   * `endowment:lifecycle-hooks` permission. If the snap does not have the\n   * permission, nothing happens.\n   *\n   * @param origin - The origin.\n   * @param snapId - The snap ID.\n   * @param handler - The lifecycle hook to call. This should be one of the\n   * supported lifecycle hooks.\n   * @private\n   */\n  async #callLifecycleHook(\n    origin: string,\n    snapId: SnapId,\n    handler: HandlerType,\n  ) {\n    const permissionName = handlerEndowments[handler];\n\n    assert(permissionName, 'Lifecycle hook must have an endowment.');\n\n    const hasPermission = this.messagingSystem.call(\n      'PermissionController:hasPermission',\n      snapId,\n      permissionName,\n    );\n\n    if (!hasPermission) {\n      return;\n    }\n\n    await this.handleRequest({\n      snapId,\n      handler,\n      origin,\n      request: {\n        jsonrpc: '2.0',\n        method: handler,\n      },\n    });\n  }\n}\n"]}