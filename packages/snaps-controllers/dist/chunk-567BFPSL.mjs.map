{"version":3,"sources":["../src/utils.ts"],"sourcesContent":["import type { PermissionConstraint } from '@metamask/permission-controller';\nimport type { SnapId } from '@metamask/snaps-sdk';\nimport { getErrorMessage } from '@metamask/snaps-sdk';\nimport {\n  encodeBase64,\n  getValidatedLocalizationFiles,\n  validateFetchedSnap,\n} from '@metamask/snaps-utils';\nimport type { Json } from '@metamask/utils';\nimport deepEqual from 'fast-deep-equal';\n\nimport type { SnapLocation } from './snaps';\nimport { Timer } from './snaps/Timer';\n\n/**\n * Takes two objects and does a Set Difference of them.\n * Set Difference is generally defined as follows:\n * ```\n * ùë• ‚àà A ‚àñ B ‚ü∫ ùë• ‚àà A ‚àß ùë• ‚àâ B\n * ```\n * Meaning that the returned object contains all properties of A expect those that also\n * appear in B. Notice that properties that appear in B, but not in A, have no effect.\n *\n * @see [Set Difference]{@link https://proofwiki.org/wiki/Definition:Set_Difference}\n * @param objectA - The object on which the difference is being calculated.\n * @param objectB - The object whose properties will be removed from objectA.\n * @returns The objectA without properties from objectB.\n */\nexport function setDiff<\n  ObjectA extends Record<any, unknown>,\n  ObjectB extends Record<any, unknown>,\n>(objectA: ObjectA, objectB: ObjectB): Diff<ObjectA, ObjectB> {\n  return Object.entries(objectA).reduce<Record<any, unknown>>(\n    (acc, [key, value]) => {\n      if (!(key in objectB)) {\n        acc[key] = value;\n      }\n      return acc;\n    },\n    {},\n  ) as Diff<ObjectA, ObjectB>;\n}\n\n/**\n * Calculate a difference between two permissions objects.\n *\n * Similar to `setDiff` except for one additional condition:\n * Permissions in B should be removed from A if they exist in both and have differing caveats.\n *\n * @param permissionsA - An object containing one or more partial permissions.\n * @param permissionsB - An object containing one or more partial permissions to be subtracted from A.\n * @returns The permissions set A without properties from B.\n */\nexport function permissionsDiff<\n  PermissionsA extends Record<string, Pick<PermissionConstraint, 'caveats'>>,\n  PermissionsB extends Record<string, Pick<PermissionConstraint, 'caveats'>>,\n>(\n  permissionsA: PermissionsA,\n  permissionsB: PermissionsB,\n): Diff<PermissionsA, PermissionsB> {\n  return Object.entries(permissionsA).reduce<\n    Record<string, Pick<PermissionConstraint, 'caveats'>>\n  >((acc, [key, value]) => {\n    const isIncluded = key in permissionsB;\n    if (\n      !isIncluded ||\n      (isIncluded &&\n        !deepEqual(value.caveats ?? [], permissionsB[key].caveats ?? []))\n    ) {\n      acc[key] = value;\n    }\n    return acc;\n  }, {}) as Diff<PermissionsA, PermissionsB>;\n}\n\n/**\n * A Promise that delays its return for a given amount of milliseconds.\n *\n * @param ms - Milliseconds to delay the execution for.\n * @param result - The result to return from the Promise after delay.\n * @returns A promise that is void if no result provided, result otherwise.\n * @template Result - The `result`.\n */\nexport function delay<Result = void>(\n  ms: number,\n  result?: Result,\n): Promise<Result> & { cancel: () => void } {\n  return delayWithTimer(new Timer(ms), result);\n}\n\n/**\n * A Promise that delays it's return by using a pausable Timer.\n *\n * @param timer - Timer used to control the delay.\n * @param result - The result to return from the Promise after delay.\n * @returns A promise that is void if no result provided, result otherwise.\n * @template Result - The `result`.\n */\nexport function delayWithTimer<Result = void>(\n  timer: Timer,\n  result?: Result,\n): Promise<Result> & { cancel: () => void } {\n  let rejectFunc: (reason: Error) => void;\n  const promise: any = new Promise<Result>((resolve: any, reject) => {\n    timer.start(() => {\n      result === undefined ? resolve() : resolve(result);\n    });\n    rejectFunc = reject;\n  });\n\n  promise.cancel = () => {\n    if (timer.status !== 'finished') {\n      timer.cancel();\n      rejectFunc(new Error('The delay has been canceled.'));\n    }\n  };\n  return promise;\n}\n\n/*\n * We use a Symbol instead of rejecting the promise so that Errors thrown\n * by the main promise will propagate.\n */\nexport const hasTimedOut = Symbol(\n  'Used to check if the requested promise has timeout (see withTimeout)',\n);\n\n/**\n * Executes the given Promise, if the Timer expires before the Promise settles, we return earlier.\n *\n * NOTE:** The given Promise is not cancelled or interrupted, and will continue to execute uninterrupted. We will just discard its result if it does not complete before the timeout.\n *\n * @param promise - The promise that you want to execute.\n * @param timerOrMs - The timer controlling the timeout or a ms value.\n * @returns The resolved `PromiseValue`, or the hasTimedOut symbol if\n * returning early.\n * @template PromiseValue - The value of the Promise.\n */\nexport async function withTimeout<PromiseValue = void>(\n  promise: Promise<PromiseValue>,\n  timerOrMs: Timer | number,\n): Promise<PromiseValue | typeof hasTimedOut> {\n  const timer =\n    typeof timerOrMs === 'number' ? new Timer(timerOrMs) : timerOrMs;\n  const delayPromise = delayWithTimer(timer, hasTimedOut);\n  try {\n    return await Promise.race([promise, delayPromise]);\n  } finally {\n    delayPromise.cancel();\n  }\n}\n\n/**\n * Checks whether the type is composed of literal types\n *\n * @returns @type {true} if whole type is composed of literals, @type {false} if whole type is not literals, @type {boolean} if mixed\n * @example\n * ```\n * type t1 = IsLiteral<1 | 2 | \"asd\" | true>;\n * // t1 = true\n *\n * type t2 = IsLiteral<number | string>;\n * // t2 = false\n *\n * type t3 = IsLiteral<1 | string>;\n * // t3 = boolean\n *\n * const s = Symbol();\n * type t4 = IsLiteral<typeof s>;\n * // t4 = true\n *\n * type t5 = IsLiteral<symbol>\n * // t5 = false;\n * ```\n */\ntype IsLiteral<Type> = Type extends string | number | boolean | symbol\n  ? Extract<string | number | boolean | symbol, Type> extends never\n    ? true\n    : false\n  : false;\n\n/**\n * Returns all keys of an object, that are literal, as an union\n *\n * @example\n * ```\n * type t1 = _LiteralKeys<{a: number, b: 0, c: 'foo', d: string}>\n * // t1 = 'b' | 'c'\n * ```\n * @see [Literal types]{@link https://www.typescriptlang.org/docs/handbook/literal-types.html}\n */\ntype LiteralKeys<Type> = NonNullable<\n  {\n    [Key in keyof Type]: IsLiteral<Key> extends true ? Key : never;\n  }[keyof Type]\n>;\n\n/**\n * Returns all keys of an object, that are not literal, as an union\n *\n * @example\n * ```\n * type t1 = _NonLiteralKeys<{a: number, b: 0, c: 'foo', d: string}>\n * // t1 = 'a' | 'd'\n * ```\n * @see [Literal types]{@link https://www.typescriptlang.org/docs/handbook/literal-types.html}\n */\ntype NonLiteralKeys<Type> = NonNullable<\n  {\n    [Key in keyof Type]: IsLiteral<Key> extends false ? Key : never;\n  }[keyof Type]\n>;\n\n/**\n * A set difference of two objects based on their keys\n *\n * @example\n * ```\n * type t1 = Diff<{a: string, b: string}, {a: number}>\n * // t1 = {b: string};\n * type t2 = Diff<{a: string, 0: string}, Record<string, unknown>>;\n * // t2 = { a?: string, 0: string};\n * type t3 = Diff<{a: string, 0: string, 1: string}, Record<1 | string, unknown>>;\n * // t3 = {a?: string, 0: string}\n * ```\n * @see {@link setDiff} for the main use-case\n */\nexport type Diff<First, Second> = Omit<First, LiteralKeys<Second>> &\n  Partial<Pick<First, Extract<keyof First, NonLiteralKeys<Second>>>>;\n\n/**\n * Makes every specified property of the specified object type mutable.\n *\n * @template Type - The object whose readonly properties to make mutable.\n * @template TargetKey - The property key(s) to make mutable.\n */\nexport type Mutable<\n  Type extends Record<string, unknown>,\n  TargetKey extends string,\n> = {\n  -readonly [Key in keyof Pick<Type, TargetKey>]: Type[Key];\n} & {\n  [Key in keyof Omit<Type, TargetKey>]: Type[Key];\n};\n\n/**\n * Get all files in a Snap from an array of file paths.\n *\n * @param location - The location of the Snap.\n * @param files - The array of file paths.\n * @returns The array of files as {@link VirtualFile}s.\n */\nexport async function getSnapFiles(\n  location: SnapLocation,\n  files?: string[] | undefined,\n) {\n  if (!files || files.length === 0) {\n    return [];\n  }\n\n  return await Promise.all(\n    files.map(async (filePath) => location.fetch(filePath)),\n  );\n}\n\n/**\n * Fetch the Snap manifest, source code, and any other files from the given\n * location.\n *\n * @param snapId - The ID of the Snap to fetch.\n * @param location - The location of the Snap.\n * @returns The Snap files and location.\n * @throws If the Snap files are invalid, or if the Snap could not be fetched.\n */\nexport async function fetchSnap(snapId: SnapId, location: SnapLocation) {\n  try {\n    const manifest = await location.manifest();\n    const sourceCode = await location.fetch(\n      manifest.result.source.location.npm.filePath,\n    );\n    const { iconPath } = manifest.result.source.location.npm;\n    const svgIcon = iconPath ? await location.fetch(iconPath) : undefined;\n\n    const auxiliaryFiles = await getSnapFiles(\n      location,\n      manifest.result.source.files,\n    );\n\n    await Promise.all(\n      auxiliaryFiles.map(async (file) => {\n        // This should still be safe\n        // eslint-disable-next-line require-atomic-updates\n        file.data.base64 = await encodeBase64(file);\n      }),\n    );\n\n    const localizationFiles = await getSnapFiles(\n      location,\n      manifest.result.source.locales,\n    );\n\n    const validatedLocalizationFiles =\n      getValidatedLocalizationFiles(localizationFiles);\n\n    const files = {\n      manifest,\n      sourceCode,\n      svgIcon,\n      auxiliaryFiles,\n      localizationFiles: validatedLocalizationFiles,\n    };\n\n    await validateFetchedSnap(files);\n\n    return files;\n  } catch (error) {\n    throw new Error(\n      `Failed to fetch snap \"${snapId}\": ${getErrorMessage(error)}.`,\n    );\n  }\n}\n\n/**\n * Calculate change of initialConnections.\n *\n * @param oldConnectionsSet - Previously approved connections.\n * @param desiredConnectionsSet - New connections.\n * @returns Object containing newConnections, unusedConnections and approvedConnections.\n */\nexport function calculateConnectionsChange(\n  oldConnectionsSet: Record<string, Json>,\n  desiredConnectionsSet: Record<string, Json>,\n): {\n  newConnections: Record<string, Json>;\n  unusedConnections: Record<string, Json>;\n  approvedConnections: Record<string, Json>;\n} {\n  const newConnections = setDiff(desiredConnectionsSet, oldConnectionsSet);\n\n  const unusedConnections = setDiff(oldConnectionsSet, desiredConnectionsSet);\n\n  // It's a Set Intersection of oldConnections and desiredConnectionsSet\n  // oldConnections ‚àñ (oldConnections ‚àñ desiredConnectionsSet) ‚ü∫ oldConnections ‚à© desiredConnectionsSet\n  const approvedConnections = setDiff(oldConnectionsSet, unusedConnections);\n\n  return { newConnections, unusedConnections, approvedConnections };\n}\n"],"mappings":"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","names":[]}