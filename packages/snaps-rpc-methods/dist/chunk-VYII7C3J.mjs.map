{"version":3,"sources":["../src/restricted/getBip32PublicKey.ts"],"sourcesContent":["import type {\n  PermissionSpecificationBuilder,\n  PermissionValidatorConstraint,\n  RestrictedMethodOptions,\n  ValidPermissionSpecification,\n} from '@metamask/permission-controller';\nimport { PermissionType, SubjectType } from '@metamask/permission-controller';\nimport { rpcErrors } from '@metamask/rpc-errors';\nimport type {\n  GetBip32PublicKeyParams,\n  GetBip32PublicKeyResult,\n} from '@metamask/snaps-sdk';\nimport {\n  bip32entropy,\n  Bip32PathStruct,\n  CurveStruct,\n  SnapCaveatType,\n} from '@metamask/snaps-utils';\nimport { boolean, object, optional } from '@metamask/superstruct';\nimport type { NonEmptyArray } from '@metamask/utils';\nimport { assertStruct } from '@metamask/utils';\n\nimport type { MethodHooksObject } from '../utils';\nimport { getNode } from '../utils';\n\nconst targetName = 'snap_getBip32PublicKey';\n\nexport type GetBip32PublicKeyMethodHooks = {\n  /**\n   * @returns The mnemonic of the user's primary keyring.\n   */\n  getMnemonic: () => Promise<Uint8Array>;\n\n  /**\n   * Waits for the extension to be unlocked.\n   *\n   * @returns A promise that resolves once the extension is unlocked.\n   */\n  getUnlockPromise: (shouldShowUnlockRequest: boolean) => Promise<void>;\n};\n\ntype GetBip32PublicKeySpecificationBuilderOptions = {\n  methodHooks: GetBip32PublicKeyMethodHooks;\n};\n\ntype GetBip32PublicKeySpecification = ValidPermissionSpecification<{\n  permissionType: PermissionType.RestrictedMethod;\n  targetName: typeof targetName;\n  methodImplementation: ReturnType<typeof getBip32PublicKeyImplementation>;\n  allowedCaveats: Readonly<NonEmptyArray<string>> | null;\n  validator: PermissionValidatorConstraint;\n}>;\n\nexport const Bip32PublicKeyArgsStruct = bip32entropy(\n  object({\n    path: Bip32PathStruct,\n    curve: CurveStruct,\n    compressed: optional(boolean()),\n  }),\n);\n\n/**\n * The specification builder for the `snap_getBip32PublicKey` permission.\n * `snap_getBip32PublicKey` lets the Snap retrieve public keys for a particular\n * BIP-32 node.\n *\n * @param options - The specification builder options.\n * @param options.methodHooks - The RPC method hooks needed by the method implementation.\n * @returns The specification for the `snap_getBip32PublicKey` permission.\n */\nconst specificationBuilder: PermissionSpecificationBuilder<\n  PermissionType.RestrictedMethod,\n  GetBip32PublicKeySpecificationBuilderOptions,\n  GetBip32PublicKeySpecification\n> = ({ methodHooks }: GetBip32PublicKeySpecificationBuilderOptions) => {\n  return {\n    permissionType: PermissionType.RestrictedMethod,\n    targetName,\n    allowedCaveats: [SnapCaveatType.PermittedDerivationPaths],\n    methodImplementation: getBip32PublicKeyImplementation(methodHooks),\n    validator: ({ caveats }) => {\n      if (\n        caveats?.length !== 1 ||\n        caveats[0].type !== SnapCaveatType.PermittedDerivationPaths\n      ) {\n        throw rpcErrors.invalidParams({\n          message: `Expected a single \"${SnapCaveatType.PermittedDerivationPaths}\" caveat.`,\n        });\n      }\n    },\n    subjectTypes: [SubjectType.Snap],\n  };\n};\n\nconst methodHooks: MethodHooksObject<GetBip32PublicKeyMethodHooks> = {\n  getMnemonic: true,\n  getUnlockPromise: true,\n};\n\nexport const getBip32PublicKeyBuilder = Object.freeze({\n  targetName,\n  specificationBuilder,\n  methodHooks,\n} as const);\n\n/**\n * Builds the method implementation for `snap_getBip32PublicKey`.\n *\n * @param hooks - The RPC method hooks.\n * @param hooks.getMnemonic - A function to retrieve the Secret Recovery Phrase of the user.\n * @param hooks.getUnlockPromise - A function that resolves once the MetaMask extension is unlocked\n * and prompts the user to unlock their MetaMask if it is locked.\n * @returns The method implementation which returns a public key.\n * @throws If the params are invalid.\n */\nexport function getBip32PublicKeyImplementation({\n  getMnemonic,\n  getUnlockPromise,\n}: GetBip32PublicKeyMethodHooks) {\n  return async function getBip32PublicKey(\n    args: RestrictedMethodOptions<GetBip32PublicKeyParams>,\n  ): Promise<GetBip32PublicKeyResult> {\n    await getUnlockPromise(true);\n\n    assertStruct(\n      args.params,\n      Bip32PublicKeyArgsStruct,\n      'Invalid BIP-32 public key params',\n      rpcErrors.invalidParams,\n    );\n\n    const { params } = args;\n    const node = await getNode({\n      curve: params.curve,\n      path: params.path,\n      secretRecoveryPhrase: await getMnemonic(),\n    });\n\n    if (params.compressed) {\n      return node.compressedPublicKey;\n    }\n\n    return node.publicKey;\n  };\n}\n"],"mappings":";;;;;AAMA,SAAS,gBAAgB,mBAAmB;AAC5C,SAAS,iBAAiB;AAK1B;AAAA,EACE;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,OACK;AACP,SAAS,SAAS,QAAQ,gBAAgB;AAE1C,SAAS,oBAAoB;AAK7B,IAAM,aAAa;AA4BZ,IAAM,2BAA2B;AAAA,EACtC,OAAO;AAAA,IACL,MAAM;AAAA,IACN,OAAO;AAAA,IACP,YAAY,SAAS,QAAQ,CAAC;AAAA,EAChC,CAAC;AACH;AAWA,IAAM,uBAIF,CAAC,EAAE,aAAAA,aAAY,MAAoD;AACrE,SAAO;AAAA,IACL,gBAAgB,eAAe;AAAA,IAC/B;AAAA,IACA,gBAAgB,CAAC,eAAe,wBAAwB;AAAA,IACxD,sBAAsB,gCAAgCA,YAAW;AAAA,IACjE,WAAW,CAAC,EAAE,QAAQ,MAAM;AAC1B,UACE,SAAS,WAAW,KACpB,QAAQ,CAAC,EAAE,SAAS,eAAe,0BACnC;AACA,cAAM,UAAU,cAAc;AAAA,UAC5B,SAAS,sBAAsB,eAAe,wBAAwB;AAAA,QACxE,CAAC;AAAA,MACH;AAAA,IACF;AAAA,IACA,cAAc,CAAC,YAAY,IAAI;AAAA,EACjC;AACF;AAEA,IAAM,cAA+D;AAAA,EACnE,aAAa;AAAA,EACb,kBAAkB;AACpB;AAEO,IAAM,2BAA2B,OAAO,OAAO;AAAA,EACpD;AAAA,EACA;AAAA,EACA;AACF,CAAU;AAYH,SAAS,gCAAgC;AAAA,EAC9C;AAAA,EACA;AACF,GAAiC;AAC/B,SAAO,eAAe,kBACpB,MACkC;AAClC,UAAM,iBAAiB,IAAI;AAE3B;AAAA,MACE,KAAK;AAAA,MACL;AAAA,MACA;AAAA,MACA,UAAU;AAAA,IACZ;AAEA,UAAM,EAAE,OAAO,IAAI;AACnB,UAAM,OAAO,MAAM,QAAQ;AAAA,MACzB,OAAO,OAAO;AAAA,MACd,MAAM,OAAO;AAAA,MACb,sBAAsB,MAAM,YAAY;AAAA,IAC1C,CAAC;AAED,QAAI,OAAO,YAAY;AACrB,aAAO,KAAK;AAAA,IACd;AAEA,WAAO,KAAK;AAAA,EACd;AACF;","names":["methodHooks"]}