{"version":3,"sources":["../src/utils.ts"],"sourcesContent":["import type {\n  HardenedBIP32Node,\n  BIP32Node,\n  SLIP10PathNode,\n  SupportedCurve,\n} from '@metamask/key-tree';\nimport { SLIP10Node } from '@metamask/key-tree';\nimport type { MagicValue } from '@metamask/snaps-utils';\nimport type { Hex } from '@metamask/utils';\nimport {\n  assertExhaustive,\n  add0x,\n  assert,\n  concatBytes,\n  createDataView,\n  stringToBytes,\n} from '@metamask/utils';\nimport { keccak_256 as keccak256 } from '@noble/hashes/sha3';\n\nconst HARDENED_VALUE = 0x80000000;\n\n/**\n * Maps an interface with method hooks to an object, using the keys of the\n * interface, and `true` as value. This ensures that the `methodHooks` object\n * has the same values as the interface.\n */\nexport type MethodHooksObject<HooksType extends Record<string, unknown>> = {\n  [Key in keyof HooksType]: true;\n};\n\n/**\n * Returns the subset of the specified `hooks` that are included in the\n * `hookNames` object. This is a Principle of Least Authority (POLA) measure\n * to ensure that each RPC method implementation only has access to the\n * API \"hooks\" it needs to do its job.\n *\n * @param hooks - The hooks to select from.\n * @param hookNames - The names of the hooks to select.\n * @returns The selected hooks.\n * @template Hooks - The hooks to select from.\n * @template HookName - The names of the hooks to select.\n */\nexport function selectHooks<\n  Hooks extends Record<string, unknown>,\n  HookName extends keyof Hooks,\n>(\n  hooks: Hooks,\n  hookNames?: Record<HookName, boolean>,\n): Pick<Hooks, HookName> | undefined {\n  if (hookNames) {\n    return Object.keys(hookNames).reduce<Partial<Pick<Hooks, HookName>>>(\n      (hookSubset, _hookName) => {\n        const hookName = _hookName as HookName;\n        hookSubset[hookName] = hooks[hookName];\n        return hookSubset;\n      },\n      {},\n    ) as Pick<Hooks, HookName>;\n  }\n  return undefined;\n}\n\n/**\n * Get a BIP-32 derivation path array from a hash, which is compatible with\n * `@metamask/key-tree`. The hash is assumed to be 32 bytes long.\n *\n * @param hash - The hash to derive indices from.\n * @returns The derived indices as a {@link HardenedBIP32Node} array.\n */\nfunction getDerivationPathArray(hash: Uint8Array): HardenedBIP32Node[] {\n  const array: HardenedBIP32Node[] = [];\n  const view = createDataView(hash);\n\n  for (let index = 0; index < 8; index++) {\n    const uint32 = view.getUint32(index * 4);\n\n    // This is essentially `index | 0x80000000`. Because JavaScript numbers are\n    // signed, we use the bitwise unsigned right shift operator to ensure that\n    // the result is a positive number.\n    // eslint-disable-next-line no-bitwise\n    const pathIndex = (uint32 | HARDENED_VALUE) >>> 0;\n    array.push(`bip32:${pathIndex - HARDENED_VALUE}'` as const);\n  }\n\n  return array;\n}\n\ntype DeriveEntropyOptions = {\n  /**\n   * The input value to derive entropy from.\n   */\n  input: string;\n\n  /**\n   * An optional salt to use when deriving entropy.\n   */\n  salt?: string;\n\n  /**\n   * The mnemonic phrase to use for entropy derivation.\n   */\n  mnemonicPhrase: Uint8Array;\n\n  /**\n   * A hardened BIP-32 index, which is used to derive the root key from the\n   * mnemonic phrase.\n   */\n  magic: MagicValue;\n};\n\n/**\n * Derive entropy from the given mnemonic phrase and salt.\n *\n * This is based on the reference implementation of\n * [SIP-6](https://metamask.github.io/SIPs/SIPS/sip-6).\n *\n * @param options - The options for entropy derivation.\n * @param options.input - The input value to derive entropy from.\n * @param options.salt - An optional salt to use when deriving entropy.\n * @param options.mnemonicPhrase - The mnemonic phrase to use for entropy\n * derivation.\n * @param options.magic - A hardened BIP-32 index, which is used to derive the\n * root key from the mnemonic phrase.\n * @returns The derived entropy.\n */\nexport async function deriveEntropy({\n  input,\n  salt = '',\n  mnemonicPhrase,\n  magic,\n}: DeriveEntropyOptions): Promise<Hex> {\n  const inputBytes = stringToBytes(input);\n  const saltBytes = stringToBytes(salt);\n\n  // Get the derivation path from the snap ID.\n  const hash = keccak256(concatBytes([inputBytes, keccak256(saltBytes)]));\n  const computedDerivationPath = getDerivationPathArray(hash);\n\n  // Derive the private key using BIP-32.\n  const { privateKey } = await SLIP10Node.fromDerivationPath({\n    derivationPath: [\n      mnemonicPhrase,\n      `bip32:${magic}`,\n      ...computedDerivationPath,\n    ],\n    curve: 'secp256k1',\n  });\n\n  // This should never happen, but this keeps TypeScript happy.\n  assert(privateKey, 'Failed to derive the entropy.');\n\n  return add0x(privateKey);\n}\n\n/**\n * Get the path prefix to use for key derivation in `key-tree`. This assumes the\n * following:\n *\n * - The Secp256k1 curve always uses the BIP-32 specification.\n * - The Ed25519 curve always uses the SLIP-10 specification.\n * - The BIP-32-Ed25519 curve always uses the CIP-3 specification.\n *\n * While this does not matter in most situations (no known case at the time of\n * writing), `key-tree` requires a specific specification to be used.\n *\n * @param curve - The curve to get the path prefix for. The curve is NOT\n * validated by this function.\n * @returns The path prefix, i.e., `bip32` or `slip10`.\n */\nexport function getPathPrefix(\n  curve: SupportedCurve,\n): 'bip32' | 'slip10' | 'cip3' {\n  switch (curve) {\n    case 'secp256k1':\n      return 'bip32';\n    case 'ed25519':\n      return 'slip10';\n    case 'ed25519Bip32':\n      return 'cip3';\n    default:\n      return assertExhaustive(curve);\n  }\n}\n\ntype GetNodeArgs = {\n  curve: SupportedCurve;\n  secretRecoveryPhrase: Uint8Array;\n  path: string[];\n};\n\n/**\n * Get a `key-tree`-compatible node.\n *\n * Note: This function assumes that all the parameters have been validated\n * beforehand.\n *\n * @param options - The derivation options.\n * @param options.curve - The curve to use for derivation.\n * @param options.secretRecoveryPhrase - The secret recovery phrase to use for\n * derivation.\n * @param options.path - The derivation path to use as array, starting with an\n * \"m\" as the first item.\n */\nexport async function getNode({\n  curve,\n  secretRecoveryPhrase,\n  path,\n}: GetNodeArgs) {\n  const prefix = getPathPrefix(curve);\n\n  return await SLIP10Node.fromDerivationPath({\n    curve,\n    derivationPath: [\n      secretRecoveryPhrase,\n      ...(path.slice(1).map((index) => `${prefix}:${index}`) as\n        | BIP32Node[]\n        | SLIP10PathNode[]),\n    ],\n  });\n}\n"],"mappings":";AAMA,SAAS,kBAAkB;AAG3B;AAAA,EACE;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,OACK;AACP,SAAS,cAAc,iBAAiB;AAExC,IAAM,iBAAiB;AAuBhB,SAAS,YAId,OACA,WACmC;AACnC,MAAI,WAAW;AACb,WAAO,OAAO,KAAK,SAAS,EAAE;AAAA,MAC5B,CAAC,YAAY,cAAc;AACzB,cAAM,WAAW;AACjB,mBAAW,QAAQ,IAAI,MAAM,QAAQ;AACrC,eAAO;AAAA,MACT;AAAA,MACA,CAAC;AAAA,IACH;AAAA,EACF;AACA,SAAO;AACT;AASA,SAAS,uBAAuB,MAAuC;AACrE,QAAM,QAA6B,CAAC;AACpC,QAAM,OAAO,eAAe,IAAI;AAEhC,WAAS,QAAQ,GAAG,QAAQ,GAAG,SAAS;AACtC,UAAM,SAAS,KAAK,UAAU,QAAQ,CAAC;AAMvC,UAAM,aAAa,SAAS,oBAAoB;AAChD,UAAM,KAAK,SAAS,YAAY,cAAc,GAAY;AAAA,EAC5D;AAEA,SAAO;AACT;AAwCA,eAAsB,cAAc;AAAA,EAClC;AAAA,EACA,OAAO;AAAA,EACP;AAAA,EACA;AACF,GAAuC;AACrC,QAAM,aAAa,cAAc,KAAK;AACtC,QAAM,YAAY,cAAc,IAAI;AAGpC,QAAM,OAAO,UAAU,YAAY,CAAC,YAAY,UAAU,SAAS,CAAC,CAAC,CAAC;AACtE,QAAM,yBAAyB,uBAAuB,IAAI;AAG1D,QAAM,EAAE,WAAW,IAAI,MAAM,WAAW,mBAAmB;AAAA,IACzD,gBAAgB;AAAA,MACd;AAAA,MACA,SAAS,KAAK;AAAA,MACd,GAAG;AAAA,IACL;AAAA,IACA,OAAO;AAAA,EACT,CAAC;AAGD,SAAO,YAAY,+BAA+B;AAElD,SAAO,MAAM,UAAU;AACzB;AAiBO,SAAS,cACd,OAC6B;AAC7B,UAAQ,OAAO;AAAA,IACb,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT;AACE,aAAO,iBAAiB,KAAK;AAAA,EACjC;AACF;AAqBA,eAAsB,QAAQ;AAAA,EAC5B;AAAA,EACA;AAAA,EACA;AACF,GAAgB;AACd,QAAM,SAAS,cAAc,KAAK;AAElC,SAAO,MAAM,WAAW,mBAAmB;AAAA,IACzC;AAAA,IACA,gBAAgB;AAAA,MACd;AAAA,MACA,GAAI,KAAK,MAAM,CAAC,EAAE,IAAI,CAAC,UAAU,GAAG,MAAM,IAAI,KAAK,EAAE;AAAA,IAGvD;AAAA,EACF,CAAC;AACH;","names":[]}